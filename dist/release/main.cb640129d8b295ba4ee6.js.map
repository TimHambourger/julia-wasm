{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/shared/memoryPool.ts","webpack:///./node_modules/classnames/index.js","webpack:///./node_modules/s-js/dist/es/S.js","webpack:///./node_modules/surplus/es/insert.js","webpack:///./node_modules/surplus/es/content.js","webpack:///./node_modules/surplus/es/dom.js","webpack:///./node_modules/surplus/es/fieldData.js","webpack:///./src/main/lib/hashSignal.ts","webpack:///./src/main/colorHandling/rgb.ts","webpack:///./src/main/queryHandler.ts","webpack:///./src/main/canvasMgr.ts","webpack:///./src/main/lib/dataBundle.ts","webpack:///./src/main/runner.ts","webpack:///./src/main/imager.ts","webpack:///./src/main/colorHandling/colorizers.ts","webpack:///./src/main/settings.ts","webpack:///./src/main/app.ts","webpack:///./src/main/settingsView.tsx","webpack:///./src/main/lib/draftSignal.ts","webpack:///./src/main/canvasView.tsx","webpack:///./src/main/appView.tsx","webpack:///./src/main/index.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","MemoryPool","[object Object]","byteLength","this","stack","buffer","Error","push","buffers","length","pop","ArrayBuffer","__WEBPACK_AMD_DEFINE_RESULT__","hasOwn","classNames","classes","arguments","arg","argType","Array","isArray","inner","apply","join","default","undefined","S","fn","owner","Owner","running","RunningNode","console","warn","node","ComputationNode","RunningClock","RootClock","changes","reset","updates","count","time","run","toplevelComputation","UNOWNED","owned","age","state","RUNNING","updateNode","to","log","Log","logRead","logComputationRead","es_S","root","result","disposer","disposes","add","S_dispose","topLevelRoot","on","ev","seed","onchanges","ss","data","DataNode","pending","NOTPENDING","S_event","logDataRead","current","eq","update","freeze","sample","cleanup","cleanups","Clock","Queue","CURRENT","source1","source1slot","sources","sourceslots","node1","node1slot","nodes","nodeslots","items","item","STALE","from","fromslot","toslot","clock","applyDataChange","markComputationsStale","markNodeStale","len","markOwnedNodesForDisposal","child","final","cleanupSource","source","slot","last","lastslot","TEXT_NODE","insert","range","parent","start","parentNode","test","good","toString","nodeType","document","createTextNode","replaceChild","end","Node","insertArray","array","nextSibling","insertBefore","appendChild","previousSibling","removeChild","Function","firstChild","lastChild","textContent","content","clear","normalizeIncomingArray","normalized","appendNodes","reconcileArrays","NOMATCH","NOINSERT","RECONCILE_ARRAY_BATCH","RECONCILE_ARRAY_BITS","RECONCILE_ARRAY_INC","RECONCILE_ARRAY_MASK","us","j","k","ulen","nmin","nmax","umin","umax","u","nx","ux","ul","loop","fixes","equable","insertOrAppend","ntext","__surplus_order","writable","Text","src","utext","preserved","lcs","seq","is","pre","findGreatestIndexLEQ","longestPositiveIncreasingSubsequence","utexti","lcsj","ntextk","marker","lo","hi","mid","Math","floor","createElement","tag","className","el","text","attrNamespaces","xlink","xml","RegExp","keys","RGBColor","RRGGBBColor","RGB","g","b","opts","isValid","hideHash","toHex","toLowerCase","str","RGBMatch","match","parseHex","RRGGBBMatch","rgb1","rgb2","NaN","parseInt","num","substr","parseQueryString","query","params","URLSearchParams","cRe","cIm","ctrRe","ctrIm","zoom","colorIn","parse","colorOut","res","iter","rad","canvas","center","re","im","resolution","escapeTime","maxIter","escapeRadius","imager","includedColor","excludedColor","ChunkSizePx","height","width","RectCalculations","canvasSizeBrowserPx","origin","chunkDelta","canvasSizeLogicalPx","centerFromOriginChunks","originOffsetPx","x","y","topLeftChunks","bottomRightChunks","canvasRect","topLeft","widthChunks","ceil","heightChunks","dataBundle_Bundle","seedFactory","dataBundle_MappedBundle","currentSlots","map","dataBundle_DataBundle","super","chunks","Map","chunkId","chunkIdKey","chunk","set","slots","forEach","original","mapFn","dispose","upstream","_dispose","prev","EscapeTimeRunner","canvasMgr","workerUrl","pool","memoryPool","resetMsgData","canvasConfig","dataGen","resultData","crack","curr","worker","Worker","onmessage","msg","type","err","Uint16Array","workerInit","chunkSizePx","pauseInterval","postMessage","instructionSeqNo","resetMsg","seqNo","returningBuffers","drain","rect","addJobsMsg","jobs","rect1","rect2","results","rectAbove","max","min","rect1Bottom","rect2Bottom","rectBelowHeight","rectBelow","rectAboveBottom","sideRectsHeight","rectLeft","rect1Right","rect2Right","rectRightWidth","rectRight","excludedRects","currentOpts","updateOpts","Imager","runner","colorizer","included","excluded","round","linearFade","imageData","prevImage","_colorizer","imageChunk","Uint8ClampedArray","acquire","magnitude","ImageData","Settings","color","theme","ColorThemes","find","ColorSettings","CANVAS_DEFAULTS","ESCAPE_TIME_DEFAULTS","IMAGER_DEFAULTS","applyDefaults","canvasOpts","centerOpts","escapeTimeOpts","cOpts","imagerOpts","includedColorOpts","excludedColorOpts","App","canvasMgrOpts","originTrigger","CanvasMgr","settings","effective","ZoomButtons","app","ColorSelector","__range","idx","__div1_select2_insert1","indexOf","e","currentTarget","invalid","__insert2","draftSignal","effectiveEq","t1","t2","dirty","written","draft","val","_curr","commit","revert","CanvasDrafts","abs","reportsSizing","drafts","mounted","timeout","updateCanvasMgrSizing","onResize","clearTimeout","setTimeout","window","addEventListener","removeEventListener","getBoundingClientRect","rendersJuliaImage","ctx","getContext","row","col","topLeftCanvasCoords","putImageData","clearRect","rendersOnZoomOut","prevBuffer","fullToDraftZoom","draftToFullZoom","targetSizePx","zoomCtr","targetCoords","targetImage","lastChunkId","chunkImage","rowPx","colPx","sourceRowPx","sourceColPx","rowOffset","colOffset","bufferOffset","isDraggable","panning","lastClientX","lastClientY","mouseDown","button","altKey","ctrlKey","metaKey","shiftKey","clientX","clientY","mouseMove","deltaX","deltaY","mouseUp","isZoomable","frameTimeout","commitTimeout","delta","onMouseWheel","preventDefault","deltaMode","WheelEvent","DOM_DELTA_LINE","zoomLocX","left","zoomLocY","top","sign","onZoomFrame","_delta","exp","pow","scale","AppView","__div1_insert3","__div1_insert5","SettingsView","__","classnames","__state","CanvasView","main_mounted","view","hash","_hash","location","_change","loc","isChange","change","onHashChange","HashSignal","slice","WORKER_URL","formatQueryString","querySelector"],"mappings":"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","file":"main.cb640129d8b295ba4ee6.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","export class MemoryPool {\n    private stack : ArrayBuffer[];\n\n    // TODO: Allow specifying a limit on the number of buffers to keep.\n    // To allow memory usage to drop if needs reduce.\n\n    constructor(\n        // Size in bytes\n        public readonly byteLength : number\n    ) {\n        this.stack = [];\n    }\n\n    /**\n     * Push a buffer back into the pool for later reuse.\n     * Throws if buffer is not at least `this.byteLength` bytes.\n     */\n    push(buffer : ArrayBuffer) {\n        if (buffer.byteLength < this.byteLength) {\n            throw new Error(`Can't absorb buffer. byteLength must be at least ${this.byteLength}`);\n        }\n        this.stack.push(buffer);\n    }\n\n    /**\n     * Push multiple buffers back into the pool.\n     * Throws if any buffer is less than `this.requiredSize()` bytes.\n     */\n    pushAll(buffers : ArrayBuffer[]) {\n        for (let i = 0; i < buffers.length; i++) {\n            this.push(buffers[i]);\n        }\n    }\n\n    /**\n     * Acquire a buffer from the pool, if one's available, otherwise constructs a new one\n     * with the min byte length.\n     */\n    acquire() {\n        return this.stack.pop() || new ArrayBuffer(this.byteLength);\n    }\n\n    /**\n     * Empty the pool and return the former contents.\n     */\n    drain() {\n        const stack = this.stack;\n        this.stack = [];\n        return stack;\n    }\n}\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","// Public interface\nvar S = function S(fn, value) {\n    var owner = Owner, running = RunningNode;\n    if (owner === null)\n        console.warn(\"computations created without a root or parent will never be disposed\");\n    var node = new ComputationNode(fn, value);\n    Owner = RunningNode = node;\n    if (RunningClock === null) {\n        toplevelComputation(node);\n    }\n    else {\n        node.value = node.fn(node.value);\n    }\n    if (owner && owner !== UNOWNED) {\n        if (owner.owned === null)\n            owner.owned = [node];\n        else\n            owner.owned.push(node);\n    }\n    Owner = owner;\n    RunningNode = running;\n    return function computation() {\n        if (RunningNode !== null) {\n            if (node.age === RootClock.time) {\n                if (node.state === RUNNING)\n                    throw new Error(\"circular dependency\");\n                else\n                    updateNode(node); // checks for state === STALE internally, so don't need to check here\n            }\n            logComputationRead(node, RunningNode);\n        }\n        return node.value;\n    };\n};\n// compatibility with commonjs systems that expect default export to be at require('s.js').default rather than just require('s-js')\nObject.defineProperty(S, 'default', { value: S });\nexport default S;\nS.root = function root(fn) {\n    var owner = Owner, root = fn.length === 0 ? UNOWNED : new ComputationNode(null, null), result = undefined, disposer = fn.length === 0 ? null : function _dispose() {\n        if (RunningClock !== null) {\n            RootClock.disposes.add(root);\n        }\n        else {\n            dispose(root);\n        }\n    };\n    Owner = root;\n    if (RunningClock === null) {\n        result = topLevelRoot(fn, disposer, owner);\n    }\n    else {\n        result = disposer === null ? fn() : fn(disposer);\n        Owner = owner;\n    }\n    return result;\n};\nfunction topLevelRoot(fn, disposer, owner) {\n    try {\n        return disposer === null ? fn() : fn(disposer);\n    }\n    finally {\n        Owner = owner;\n    }\n}\nS.on = function on(ev, fn, seed, onchanges) {\n    if (Array.isArray(ev))\n        ev = callAll(ev);\n    onchanges = !!onchanges;\n    return S(on, seed);\n    function on(value) {\n        var running = RunningNode;\n        ev();\n        if (onchanges)\n            onchanges = false;\n        else {\n            RunningNode = null;\n            value = fn(value);\n            RunningNode = running;\n        }\n        return value;\n    }\n};\nfunction callAll(ss) {\n    return function all() {\n        for (var i = 0; i < ss.length; i++)\n            ss[i]();\n    };\n}\nS.data = function data(value) {\n    var node = new DataNode(value);\n    return function data(value) {\n        if (arguments.length > 0) {\n            if (RunningClock !== null) {\n                if (node.pending !== NOTPENDING) {\n                    if (value !== node.pending) {\n                        throw new Error(\"conflicting changes: \" + value + \" !== \" + node.pending);\n                    }\n                }\n                else {\n                    node.pending = value;\n                    RootClock.changes.add(node);\n                }\n            }\n            else {\n                if (node.log !== null) {\n                    node.pending = value;\n                    RootClock.changes.add(node);\n                    event();\n                }\n                else {\n                    node.value = value;\n                }\n            }\n            return value;\n        }\n        else {\n            if (RunningNode !== null) {\n                logDataRead(node, RunningNode);\n            }\n            return node.value;\n        }\n    };\n};\nS.value = function value(current, eq) {\n    var data = S.data(current), age = -1;\n    return function value(update) {\n        if (arguments.length === 0) {\n            return data();\n        }\n        else {\n            var same = eq ? eq(current, update) : current === update;\n            if (!same) {\n                var time = RootClock.time;\n                if (age === time)\n                    throw new Error(\"conflicting values: \" + update + \" is not the same as \" + current);\n                age = time;\n                current = update;\n                data(update);\n            }\n            return update;\n        }\n    };\n};\nS.freeze = function freeze(fn) {\n    var result = undefined;\n    if (RunningClock !== null) {\n        result = fn();\n    }\n    else {\n        RunningClock = RootClock;\n        RunningClock.changes.reset();\n        try {\n            result = fn();\n            event();\n        }\n        finally {\n            RunningClock = null;\n        }\n    }\n    return result;\n};\nS.sample = function sample(fn) {\n    var result, running = RunningNode;\n    if (running !== null) {\n        RunningNode = null;\n        result = fn();\n        RunningNode = running;\n    }\n    else {\n        result = fn();\n    }\n    return result;\n};\nS.cleanup = function cleanup(fn) {\n    if (Owner !== null) {\n        if (Owner.cleanups === null)\n            Owner.cleanups = [fn];\n        else\n            Owner.cleanups.push(fn);\n    }\n    else {\n        console.warn(\"cleanups created without a root or parent will never be run\");\n    }\n};\n// Internal implementation\n/// Graph classes and operations\nvar Clock = /** @class */ (function () {\n    function Clock() {\n        this.time = 0;\n        this.changes = new Queue(); // batched changes to data nodes\n        this.updates = new Queue(); // computations to update\n        this.disposes = new Queue(); // disposals to run after current batch of updates finishes\n    }\n    return Clock;\n}());\nvar DataNode = /** @class */ (function () {\n    function DataNode(value) {\n        this.value = value;\n        this.pending = NOTPENDING;\n        this.log = null;\n    }\n    return DataNode;\n}());\nvar ComputationNode = /** @class */ (function () {\n    function ComputationNode(fn, value) {\n        this.fn = fn;\n        this.value = value;\n        this.state = CURRENT;\n        this.source1 = null;\n        this.source1slot = 0;\n        this.sources = null;\n        this.sourceslots = null;\n        this.log = null;\n        this.owned = null;\n        this.cleanups = null;\n        this.age = RootClock.time;\n    }\n    return ComputationNode;\n}());\nvar Log = /** @class */ (function () {\n    function Log() {\n        this.node1 = null;\n        this.node1slot = 0;\n        this.nodes = null;\n        this.nodeslots = null;\n    }\n    return Log;\n}());\nvar Queue = /** @class */ (function () {\n    function Queue() {\n        this.items = [];\n        this.count = 0;\n    }\n    Queue.prototype.reset = function () {\n        this.count = 0;\n    };\n    Queue.prototype.add = function (item) {\n        this.items[this.count++] = item;\n    };\n    Queue.prototype.run = function (fn) {\n        var items = this.items;\n        for (var i = 0; i < this.count; i++) {\n            fn(items[i]);\n            items[i] = null;\n        }\n        this.count = 0;\n    };\n    return Queue;\n}());\n// Constants\nvar NOTPENDING = {}, CURRENT = 0, STALE = 1, RUNNING = 2;\n// \"Globals\" used to keep track of current system state\nvar RootClock = new Clock(), RunningClock = null, // currently running clock \nRunningNode = null, // currently running computation\nOwner = null, // owner for new computations\nUNOWNED = new ComputationNode(null, null);\n// Functions\nfunction logRead(from, to) {\n    var fromslot, toslot = to.source1 === null ? -1 : to.sources === null ? 0 : to.sources.length;\n    if (from.node1 === null) {\n        from.node1 = to;\n        from.node1slot = toslot;\n        fromslot = -1;\n    }\n    else if (from.nodes === null) {\n        from.nodes = [to];\n        from.nodeslots = [toslot];\n        fromslot = 0;\n    }\n    else {\n        fromslot = from.nodes.length;\n        from.nodes.push(to);\n        from.nodeslots.push(toslot);\n    }\n    if (to.source1 === null) {\n        to.source1 = from;\n        to.source1slot = fromslot;\n    }\n    else if (to.sources === null) {\n        to.sources = [from];\n        to.sourceslots = [fromslot];\n    }\n    else {\n        to.sources.push(from);\n        to.sourceslots.push(fromslot);\n    }\n}\nfunction logDataRead(data, to) {\n    if (data.log === null)\n        data.log = new Log();\n    logRead(data.log, to);\n}\nfunction logComputationRead(node, to) {\n    if (node.log === null)\n        node.log = new Log();\n    logRead(node.log, to);\n}\nfunction event() {\n    // b/c we might be under a top level S.root(), have to preserve current root\n    var owner = Owner;\n    RootClock.updates.reset();\n    RootClock.time++;\n    try {\n        run(RootClock);\n    }\n    finally {\n        RunningClock = RunningNode = null;\n        Owner = owner;\n    }\n}\nfunction toplevelComputation(node) {\n    RunningClock = RootClock;\n    RootClock.changes.reset();\n    RootClock.updates.reset();\n    try {\n        node.value = node.fn(node.value);\n        if (RootClock.changes.count > 0 || RootClock.updates.count > 0) {\n            RootClock.time++;\n            run(RootClock);\n        }\n    }\n    finally {\n        RunningClock = Owner = RunningNode = null;\n    }\n}\nfunction run(clock) {\n    var running = RunningClock, count = 0;\n    RunningClock = clock;\n    clock.disposes.reset();\n    // for each batch ...\n    while (clock.changes.count !== 0 || clock.updates.count !== 0 || clock.disposes.count !== 0) {\n        if (count > 0)\n            clock.time++;\n        clock.changes.run(applyDataChange);\n        clock.updates.run(updateNode);\n        clock.disposes.run(dispose);\n        // if there are still changes after excessive batches, assume runaway            \n        if (count++ > 1e5) {\n            throw new Error(\"Runaway clock detected\");\n        }\n    }\n    RunningClock = running;\n}\nfunction applyDataChange(data) {\n    data.value = data.pending;\n    data.pending = NOTPENDING;\n    if (data.log)\n        markComputationsStale(data.log);\n}\nfunction markComputationsStale(log) {\n    var node1 = log.node1, nodes = log.nodes;\n    // mark all downstream nodes stale which haven't been already\n    if (node1 !== null)\n        markNodeStale(node1);\n    if (nodes !== null) {\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            markNodeStale(nodes[i]);\n        }\n    }\n}\nfunction markNodeStale(node) {\n    var time = RootClock.time;\n    if (node.age < time) {\n        node.age = time;\n        node.state = STALE;\n        RootClock.updates.add(node);\n        if (node.owned !== null)\n            markOwnedNodesForDisposal(node.owned);\n        if (node.log !== null)\n            markComputationsStale(node.log);\n    }\n}\nfunction markOwnedNodesForDisposal(owned) {\n    for (var i = 0; i < owned.length; i++) {\n        var child = owned[i];\n        child.age = RootClock.time;\n        child.state = CURRENT;\n        if (child.owned !== null)\n            markOwnedNodesForDisposal(child.owned);\n    }\n}\nfunction updateNode(node) {\n    if (node.state === STALE) {\n        var owner = Owner, running = RunningNode;\n        Owner = RunningNode = node;\n        node.state = RUNNING;\n        cleanup(node, false);\n        node.value = node.fn(node.value);\n        node.state = CURRENT;\n        Owner = owner;\n        RunningNode = running;\n    }\n}\nfunction cleanup(node, final) {\n    var source1 = node.source1, sources = node.sources, sourceslots = node.sourceslots, cleanups = node.cleanups, owned = node.owned, i, len;\n    if (cleanups !== null) {\n        for (i = 0; i < cleanups.length; i++) {\n            cleanups[i](final);\n        }\n        node.cleanups = null;\n    }\n    if (owned !== null) {\n        for (i = 0; i < owned.length; i++) {\n            dispose(owned[i]);\n        }\n        node.owned = null;\n    }\n    if (source1 !== null) {\n        cleanupSource(source1, node.source1slot);\n        node.source1 = null;\n    }\n    if (sources !== null) {\n        for (i = 0, len = sources.length; i < len; i++) {\n            cleanupSource(sources.pop(), sourceslots.pop());\n        }\n    }\n}\nfunction cleanupSource(source, slot) {\n    var nodes = source.nodes, nodeslots = source.nodeslots, last, lastslot;\n    if (slot === -1) {\n        source.node1 = null;\n    }\n    else {\n        last = nodes.pop();\n        lastslot = nodeslots.pop();\n        if (slot !== nodes.length) {\n            nodes[slot] = last;\n            nodeslots[slot] = lastslot;\n            if (lastslot === -1) {\n                last.source1slot = slot;\n            }\n            else {\n                last.sourceslots[lastslot] = slot;\n            }\n        }\n    }\n}\nfunction dispose(node) {\n    node.fn = null;\n    node.log = null;\n    cleanup(node, true);\n}\n","import { S } from './index';\nvar DOCUMENT_FRAGMENT_NODE = 11, TEXT_NODE = 3;\nexport function insert(range, value) {\n    var parent = range.start.parentNode, test = range.start, good = null, t = typeof value;\n    //if (parent === null) {\n    //    throw new Error(\"Surplus.insert() can only be used on a node that has a parent node. \\n\"\n    //        + \"Node ``\" + range.start + \"'' is currently unattached to a parent.\");\n    //}\n    //if (range.end.parentNode !== parent) {\n    //    throw new Error(\"Surplus.insert() requires that the inserted nodes remain sibilings \\n\"\n    //        + \"of the original node.  The DOM has been modified such that this is \\n\"\n    //        + \"no longer the case.\");\n    //}\n    if (t === 'string' || t === 'number') {\n        value = value.toString();\n        if (test.nodeType === TEXT_NODE) {\n            test.data = value;\n            good = test;\n        }\n        else {\n            value = document.createTextNode(value);\n            parent.replaceChild(value, test);\n            if (range.end === test)\n                range.end = value;\n            range.start = good = value;\n        }\n    }\n    else if (value instanceof Node) {\n        if (test !== value) {\n            parent.replaceChild(value, test);\n            if (range.end === test)\n                range.end = value;\n            range.start = value;\n        }\n        good = value;\n    }\n    else if (Array.isArray(value)) {\n        insertArray(value);\n    }\n    else if (value instanceof Function) {\n        S(function () {\n            insert(range, value());\n        });\n        good = range.end;\n    }\n    else if (value !== null && value !== undefined && value !== true && value !== false) {\n        value = value.toString();\n        if (test.nodeType === TEXT_NODE) {\n            test.data = value;\n            good = test;\n        }\n        else {\n            value = document.createTextNode(value);\n            parent.replaceChild(value, test);\n            if (range.end === test)\n                range.end = value;\n            range.start = good = value;\n        }\n    }\n    if (good === null) {\n        if (range.start === parent.firstChild && range.end === parent.lastChild && range.start !== range.end) {\n            // fast delete entire contents\n            parent.textContent = \"\";\n            value = document.createTextNode(\"\");\n            parent.appendChild(value);\n            good = range.start = range.end = value;\n        }\n        else if (test.nodeType === TEXT_NODE) {\n            test.data = \"\";\n            good = test;\n        }\n        else {\n            value = document.createTextNode(\"\");\n            parent.replaceChild(value, test);\n            if (range.end === test)\n                range.end = value;\n            range.start = good = value;\n        }\n    }\n    // remove anything left after the good cursor from the insert range\n    while (good !== range.end) {\n        test = range.end;\n        range.end = test.previousSibling;\n        parent.removeChild(test);\n    }\n    return range;\n    function insertArray(array) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            var value = array[i];\n            if (good === range.end) {\n                if (value instanceof Node) {\n                    good = range.end = (good.nextSibling ? parent.insertBefore(value, good.nextSibling) : parent.appendChild(value));\n                }\n                else if (value instanceof Array) {\n                    insertArray(value);\n                }\n                else if (value !== null && value !== undefined && value !== false && value !== true) {\n                    value = document.createTextNode(value.toString());\n                    good = range.end = (good.nextSibling ? parent.insertBefore(value, good.nextSibling) : parent.appendChild(value));\n                }\n            }\n            else {\n                if (value instanceof Node) {\n                    if (test !== value) {\n                        if (good === null) {\n                            if (range.end === value)\n                                range.end = value.previousSibling;\n                            parent.replaceChild(value, test);\n                            range.start = value;\n                            if (range.end === test)\n                                range.end = value;\n                            test = value.nextSibling;\n                        }\n                        else {\n                            if (test.nextSibling === value && test !== value.nextSibling && test !== range.end) {\n                                parent.removeChild(test);\n                                test = value.nextSibling;\n                            }\n                            else {\n                                if (range.end === value)\n                                    range.end = value.previousSibling;\n                                parent.insertBefore(value, test);\n                            }\n                        }\n                    }\n                    else {\n                        test = test.nextSibling;\n                    }\n                    good = value;\n                }\n                else if (value instanceof Array) {\n                    insertArray(value);\n                }\n                else if (value !== null && value !== undefined && value !== true && value !== false) {\n                    value = value.toString();\n                    if (test.nodeType === TEXT_NODE) {\n                        test.data = value;\n                        if (good === null)\n                            range.start = test;\n                        good = test, test = good.nextSibling;\n                    }\n                    else {\n                        value = document.createTextNode(value);\n                        parent.insertBefore(value, test);\n                        if (good === null)\n                            range.start = value;\n                        good = value;\n                    }\n                }\n            }\n        }\n    }\n}\n","import { S } from './index';\nexport function content(parent, value, current) {\n    var t = typeof value;\n    if (current === value) {\n        // nothing to do\n    }\n    else if (t === 'string') {\n        // if a Text node already exists, it's faster to set its .data than set the parent.textContent\n        if (current !== \"\" && typeof current === 'string') {\n            current = parent.firstChild.data = value;\n        }\n        else {\n            current = parent.textContent = value;\n        }\n    }\n    else if (t === 'number') {\n        value = value.toString();\n        if (current !== \"\" && typeof current === 'string') {\n            current = parent.firstChild.data = value;\n        }\n        else {\n            current = parent.textContent = value;\n        }\n    }\n    else if (value == null || t === 'boolean') {\n        clear(parent);\n        current = \"\";\n    }\n    else if (t === 'function') {\n        S(function () {\n            current = content(parent, value(), current);\n        });\n    }\n    else if (value instanceof Node) {\n        if (Array.isArray(current)) {\n            if (current.length === 0) {\n                parent.appendChild(value);\n            }\n            else if (current.length === 1) {\n                parent.replaceChild(value, current[0]);\n            }\n            else {\n                clear(parent);\n                parent.appendChild(value);\n            }\n        }\n        else if (current === \"\") {\n            parent.appendChild(value);\n        }\n        else {\n            parent.replaceChild(value, parent.firstChild);\n        }\n        current = value;\n    }\n    else if (Array.isArray(value)) {\n        var array = normalizeIncomingArray([], value);\n        if (array.length === 0) {\n            clear(parent);\n        }\n        else {\n            if (Array.isArray(current)) {\n                if (current.length === 0) {\n                    appendNodes(parent, array, 0, array.length);\n                }\n                else {\n                    reconcileArrays(parent, current, array);\n                }\n            }\n            else if (current === \"\") {\n                appendNodes(parent, array, 0, array.length);\n            }\n            else {\n                reconcileArrays(parent, [parent.firstChild], array);\n            }\n        }\n        current = array;\n    }\n    else {\n        throw new Error(\"content must be Node, stringable, or array of same\");\n    }\n    return current;\n}\nvar NOMATCH = -1, NOINSERT = -2;\nvar RECONCILE_ARRAY_BATCH = 0;\nvar RECONCILE_ARRAY_BITS = 16, RECONCILE_ARRAY_INC = 1 << RECONCILE_ARRAY_BITS, RECONCILE_ARRAY_MASK = RECONCILE_ARRAY_INC - 1;\n// reconcile the content of parent from ns to us\n// see ivi's excellent writeup of diffing arrays in a vdom library: \n// https://github.com/ivijs/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1187\n// this code isn't identical, since we're diffing real dom nodes to nodes-or-strings, \n// but the core methodology of trimming ends and reversals, matching nodes, then using\n// the longest increasing subsequence to minimize DOM ops is inspired by ivi.\nfunction reconcileArrays(parent, ns, us) {\n    var ulen = us.length, \n    // n = nodes, u = updates\n    // ranges defined by min and max indices\n    nmin = 0, nmax = ns.length - 1, umin = 0, umax = ulen - 1, \n    // start nodes of ranges\n    n = ns[nmin], u = us[umin], \n    // end nodes of ranges\n    nx = ns[nmax], ux = us[umax], \n    // node, if any, just after ux, used for doing .insertBefore() to put nodes at end\n    ul = nx.nextSibling, i, j, k, loop = true;\n    // scan over common prefixes, suffixes, and simple reversals\n    fixes: while (loop) {\n        loop = false;\n        // common prefix, u === n\n        while (equable(u, n, umin, us)) {\n            umin++;\n            nmin++;\n            if (umin > umax || nmin > nmax)\n                break fixes;\n            u = us[umin];\n            n = ns[nmin];\n        }\n        // common suffix, ux === nx\n        while (equable(ux, nx, umax, us)) {\n            ul = nx;\n            umax--;\n            nmax--;\n            if (umin > umax || nmin > nmax)\n                break fixes;\n            ux = us[umax];\n            nx = ns[nmax];\n        }\n        // reversal u === nx, have to swap node forward\n        while (equable(u, nx, umin, us)) {\n            loop = true;\n            parent.insertBefore(nx, n);\n            umin++;\n            nmax--;\n            if (umin > umax || nmin > nmax)\n                break fixes;\n            u = us[umin];\n            nx = ns[nmax];\n        }\n        // reversal ux === n, have to swap node back\n        while (equable(ux, n, umax, us)) {\n            loop = true;\n            if (ul === null)\n                parent.appendChild(n);\n            else\n                parent.insertBefore(n, ul);\n            ul = n;\n            umax--;\n            nmin++;\n            if (umin > umax || nmin > nmax)\n                break fixes;\n            ux = us[umax];\n            n = ns[nmin];\n        }\n    }\n    // if that covered all updates, just need to remove any remaining nodes and we're done\n    if (umin > umax) {\n        // remove any remaining nodes\n        while (nmin <= nmax) {\n            parent.removeChild(ns[nmax]);\n            nmax--;\n        }\n        return;\n    }\n    // if that covered all current nodes, just need to insert any remaining updates and we're done\n    if (nmin > nmax) {\n        // insert any remaining nodes\n        while (umin <= umax) {\n            insertOrAppend(parent, us[umin], ul, umin, us);\n            umin++;\n        }\n        return;\n    }\n    // simple cases don't apply, have to actually match up nodes and figure out minimum DOM ops\n    // loop through nodes and mark them with a special property indicating their order\n    // we'll then go through the updates and look for those properties\n    // in case any of the updates have order properties left over from earlier runs, we \n    // use the low bits of the order prop to record a batch identifier.\n    // I'd much rather use a Map than a special property, but Maps of objects are really\n    // slow currently, like only 100k get/set ops / second\n    // for Text nodes, all that matters is their order, as they're easily, interchangeable\n    // so we record their positions in ntext[]\n    var ntext = [];\n    // update global batch identifer\n    RECONCILE_ARRAY_BATCH = (RECONCILE_ARRAY_BATCH + 1) % RECONCILE_ARRAY_INC;\n    for (i = nmin, j = (nmin << RECONCILE_ARRAY_BITS) + RECONCILE_ARRAY_BATCH; i <= nmax; i++, j += RECONCILE_ARRAY_INC) {\n        n = ns[i];\n        // add or update special order property\n        if (n.__surplus_order === undefined) {\n            Object.defineProperty(n, '__surplus_order', { value: j, writable: true });\n        }\n        else {\n            n.__surplus_order = j;\n        }\n        if (n instanceof Text) {\n            ntext.push(i);\n        }\n    }\n    // now loop through us, looking for the order property, otherwise recording NOMATCH\n    var src = new Array(umax - umin + 1), utext = [], preserved = 0;\n    for (i = umin; i <= umax; i++) {\n        u = us[i];\n        if (typeof u === 'string') {\n            utext.push(i);\n            src[i - umin] = NOMATCH;\n        }\n        else if ((j = u.__surplus_order) !== undefined && (j & RECONCILE_ARRAY_MASK) === RECONCILE_ARRAY_BATCH) {\n            j >>= RECONCILE_ARRAY_BITS;\n            src[i - umin] = j;\n            ns[j] = null;\n            preserved++;\n        }\n        else {\n            src[i - umin] = NOMATCH;\n        }\n    }\n    if (preserved === 0 && nmin === 0 && nmax === ns.length - 1) {\n        // no nodes preserved, use fast clear and append\n        clear(parent);\n        while (umin <= umax) {\n            insertOrAppend(parent, us[umin], null, umin, us);\n            umin++;\n        }\n        return;\n    }\n    // find longest common sequence between ns and us, represented as the indices \n    // of the longest increasing subsequence in src\n    var lcs = longestPositiveIncreasingSubsequence(src);\n    // we know we can preserve their order, so march them as NOINSERT\n    for (i = 0; i < lcs.length; i++) {\n        src[lcs[i]] = NOINSERT;\n    }\n    /*\n              0   1   2   3   4   5   6   7\n    ns    = [ n,  n,  t,  n,  n,  n,  t,  n ]\n                  |          /   /       /\n                  |        /   /       /\n                  +------/---/-------/----+\n                       /   /       /      |\n    us    = [ n,  s,  n,  n,  s,  n,  s,  n ]\n    src   = [-1, -1,  4,  5, -1,  7, -1,  1 ]\n    lis   = [         2,  3,      5]\n                      j\n    utext = [     1,          4,      6 ]\n                  i\n    ntext = [         2,              6 ]\n                      k\n    */\n    // replace strings in us with Text nodes, reusing Text nodes from ns when we can do so without moving them\n    var utexti = 0, lcsj = 0, ntextk = 0;\n    for (i = 0, j = 0, k = 0; i < utext.length; i++) {\n        utexti = utext[i];\n        // need to answer qeustion \"if utext[i] falls between two lcs nodes, is there an ntext between them which we can reuse?\"\n        // first, find j such that lcs[j] is the first lcs node *after* utext[i]\n        while (j < lcs.length && (lcsj = lcs[j]) < utexti - umin)\n            j++;\n        // now, find k such that ntext[k] is the first ntext *after* lcs[j-1] (or after start, if j === 0)\n        while (k < ntext.length && (ntextk = ntext[k], j !== 0) && ntextk < src[lcs[j - 1]])\n            k++;\n        // if ntext[k] < lcs[j], then we know ntext[k] falls between lcs[j-1] (or start) and lcs[j] (or end)\n        // that means we can re-use it without moving it\n        if (k < ntext.length && (j === lcs.length || ntextk < src[lcsj])) {\n            n = ns[ntextk];\n            u = us[utexti];\n            if (n.data !== u)\n                n.data = u;\n            ns[ntextk] = null;\n            us[utexti] = n;\n            src[utexti] = NOINSERT;\n            k++;\n        }\n        else {\n            // if we didn't find one to re-use, make a new Text node\n            us[utexti] = document.createTextNode(us[utexti]);\n        }\n    }\n    // remove stale nodes in ns\n    while (nmin <= nmax) {\n        n = ns[nmin];\n        if (n !== null) {\n            parent.removeChild(n);\n        }\n        nmin++;\n    }\n    // insert new nodes\n    while (umin <= umax) {\n        ux = us[umax];\n        if (src[umax - umin] !== NOINSERT) {\n            if (ul === null)\n                parent.appendChild(ux);\n            else\n                parent.insertBefore(ux, ul);\n        }\n        ul = ux;\n        umax--;\n    }\n}\n// two nodes are \"equable\" if they are identical (===) or if we can make them the same, i.e. they're \n// Text nodes, which we can reuse with the new text\nfunction equable(u, n, i, us) {\n    if (u === n) {\n        return true;\n    }\n    else if (typeof u === 'string' && n instanceof Text) {\n        if (n.data !== u)\n            n.data = u;\n        us[i] = n;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction appendNodes(parent, array, i, end) {\n    var node;\n    for (; i < end; i++) {\n        node = array[i];\n        if (node instanceof Node) {\n            parent.appendChild(node);\n        }\n        else {\n            node = array[i] = document.createTextNode(node);\n            parent.appendChild(node);\n        }\n    }\n}\nfunction insertOrAppend(parent, node, marker, i, us) {\n    if (typeof node === 'string') {\n        node = us[i] = document.createTextNode(node);\n    }\n    if (marker === null)\n        parent.appendChild(node);\n    else\n        parent.insertBefore(node, marker);\n}\nfunction normalizeIncomingArray(normalized, array) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        var item = array[i];\n        if (item instanceof Node) {\n            normalized.push(item);\n        }\n        else if (item == null || item === true || item === false) {\n            // skip\n        }\n        else if (Array.isArray(item)) {\n            normalizeIncomingArray(normalized, item);\n        }\n        else if (typeof item === 'string') {\n            normalized.push(item);\n        }\n        else {\n            normalized.push(item.toString());\n        }\n    }\n    return normalized;\n}\nfunction clear(node) {\n    node.textContent = \"\";\n}\n// return an array of the indices of ns that comprise the longest increasing subsequence within ns\nfunction longestPositiveIncreasingSubsequence(ns) {\n    var seq = [], is = [], l = -1, pre = new Array(ns.length);\n    for (var i = 0, len = ns.length; i < len; i++) {\n        var n = ns[i];\n        if (n < 0)\n            continue;\n        var j = findGreatestIndexLEQ(seq, n);\n        if (j !== -1)\n            pre[i] = is[j];\n        if (j === l) {\n            l++;\n            seq[l] = n;\n            is[l] = i;\n        }\n        else if (n < seq[j + 1]) {\n            seq[j + 1] = n;\n            is[j + 1] = i;\n        }\n    }\n    for (i = is[l]; l >= 0; i = pre[i], l--) {\n        seq[l] = i;\n    }\n    return seq;\n}\nfunction findGreatestIndexLEQ(seq, n) {\n    // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n    // therefore, they actually start out of range: (-1, last + 1)\n    var lo = -1, hi = seq.length;\n    // fast path for simple increasing sequences\n    if (hi > 0 && seq[hi - 1] <= n)\n        return hi - 1;\n    while (hi - lo > 1) {\n        var mid = Math.floor((lo + hi) / 2);\n        if (seq[mid] > n) {\n            hi = mid;\n        }\n        else {\n            lo = mid;\n        }\n    }\n    return lo;\n}\n","var svgNS = \"http://www.w3.org/2000/svg\";\nexport function createElement(tag, className, parent) {\n    var el = document.createElement(tag);\n    if (className)\n        el.className = className;\n    if (parent)\n        parent.appendChild(el);\n    return el;\n}\nexport function createSvgElement(tag, className, parent) {\n    var el = document.createElementNS(svgNS, tag);\n    if (className)\n        el.setAttribute(\"class\", className);\n    if (parent)\n        parent.appendChild(el);\n    return el;\n}\nexport function createComment(text, parent) {\n    var comment = document.createComment(text);\n    parent.appendChild(comment);\n    return comment;\n}\nexport function createTextNode(text, parent) {\n    var node = document.createTextNode(text);\n    parent.appendChild(node);\n    return node;\n}\nexport function setAttribute(node, name, value) {\n    if (value === false || value === null || value === undefined)\n        node.removeAttribute(name);\n    else\n        node.setAttribute(name, value);\n}\nexport function setAttributeNS(node, namespace, name, value) {\n    if (value === false || value === null || value === undefined)\n        node.removeAttributeNS(namespace, name);\n    else\n        node.setAttributeNS(namespace, name, value);\n}\n","var \n// pre-seed the caches with a few special cases, so we don't need to check for them in the common cases\nhtmlFieldCache = {\n    // special props\n    style: ['style', null, 3 /* Assign */],\n    ref: ['ref', null, 2 /* Ignore */],\n    fn: ['fn', null, 2 /* Ignore */],\n    // attr compat\n    class: ['className', null, 0 /* Property */],\n    for: ['htmlFor', null, 0 /* Property */],\n    \"accept-charset\": ['acceptCharset', null, 0 /* Property */],\n    \"http-equiv\": ['httpEquiv', null, 0 /* Property */],\n    // a few React oddities, mostly disagreeing about casing\n    onDoubleClick: ['ondblclick', null, 0 /* Property */],\n    spellCheck: ['spellcheck', null, 0 /* Property */],\n    allowFullScreen: ['allowFullscreen', null, 0 /* Property */],\n    autoCapitalize: ['autocapitalize', null, 0 /* Property */],\n    autoFocus: ['autofocus', null, 0 /* Property */],\n    autoPlay: ['autoplay', null, 0 /* Property */],\n    // other\n    // role is part of the ARIA spec but not caught by the aria- attr filter\n    role: ['role', null, 1 /* Attribute */]\n}, svgFieldCache = {\n    // special props\n    style: ['style', null, 3 /* Assign */],\n    ref: ['ref', null, 2 /* Ignore */],\n    fn: ['fn', null, 2 /* Ignore */],\n    // property compat\n    className: ['class', null, 1 /* Attribute */],\n    htmlFor: ['for', null, 1 /* Attribute */],\n    tabIndex: ['tabindex', null, 1 /* Attribute */],\n    // React compat\n    onDoubleClick: ['ondblclick', null, 0 /* Property */],\n    // attributes with eccentric casing - some SVG attrs are snake-cased, some camelCased\n    allowReorder: ['allowReorder', null, 1 /* Attribute */],\n    attributeName: ['attributeName', null, 1 /* Attribute */],\n    attributeType: ['attributeType', null, 1 /* Attribute */],\n    autoReverse: ['autoReverse', null, 1 /* Attribute */],\n    baseFrequency: ['baseFrequency', null, 1 /* Attribute */],\n    calcMode: ['calcMode', null, 1 /* Attribute */],\n    clipPathUnits: ['clipPathUnits', null, 1 /* Attribute */],\n    contentScriptType: ['contentScriptType', null, 1 /* Attribute */],\n    contentStyleType: ['contentStyleType', null, 1 /* Attribute */],\n    diffuseConstant: ['diffuseConstant', null, 1 /* Attribute */],\n    edgeMode: ['edgeMode', null, 1 /* Attribute */],\n    externalResourcesRequired: ['externalResourcesRequired', null, 1 /* Attribute */],\n    filterRes: ['filterRes', null, 1 /* Attribute */],\n    filterUnits: ['filterUnits', null, 1 /* Attribute */],\n    gradientTransform: ['gradientTransform', null, 1 /* Attribute */],\n    gradientUnits: ['gradientUnits', null, 1 /* Attribute */],\n    kernelMatrix: ['kernelMatrix', null, 1 /* Attribute */],\n    kernelUnitLength: ['kernelUnitLength', null, 1 /* Attribute */],\n    keyPoints: ['keyPoints', null, 1 /* Attribute */],\n    keySplines: ['keySplines', null, 1 /* Attribute */],\n    keyTimes: ['keyTimes', null, 1 /* Attribute */],\n    lengthAdjust: ['lengthAdjust', null, 1 /* Attribute */],\n    limitingConeAngle: ['limitingConeAngle', null, 1 /* Attribute */],\n    markerHeight: ['markerHeight', null, 1 /* Attribute */],\n    markerUnits: ['markerUnits', null, 1 /* Attribute */],\n    maskContentUnits: ['maskContentUnits', null, 1 /* Attribute */],\n    maskUnits: ['maskUnits', null, 1 /* Attribute */],\n    numOctaves: ['numOctaves', null, 1 /* Attribute */],\n    pathLength: ['pathLength', null, 1 /* Attribute */],\n    patternContentUnits: ['patternContentUnits', null, 1 /* Attribute */],\n    patternTransform: ['patternTransform', null, 1 /* Attribute */],\n    patternUnits: ['patternUnits', null, 1 /* Attribute */],\n    pointsAtX: ['pointsAtX', null, 1 /* Attribute */],\n    pointsAtY: ['pointsAtY', null, 1 /* Attribute */],\n    pointsAtZ: ['pointsAtZ', null, 1 /* Attribute */],\n    preserveAlpha: ['preserveAlpha', null, 1 /* Attribute */],\n    preserveAspectRatio: ['preserveAspectRatio', null, 1 /* Attribute */],\n    primitiveUnits: ['primitiveUnits', null, 1 /* Attribute */],\n    refX: ['refX', null, 1 /* Attribute */],\n    refY: ['refY', null, 1 /* Attribute */],\n    repeatCount: ['repeatCount', null, 1 /* Attribute */],\n    repeatDur: ['repeatDur', null, 1 /* Attribute */],\n    requiredExtensions: ['requiredExtensions', null, 1 /* Attribute */],\n    requiredFeatures: ['requiredFeatures', null, 1 /* Attribute */],\n    specularConstant: ['specularConstant', null, 1 /* Attribute */],\n    specularExponent: ['specularExponent', null, 1 /* Attribute */],\n    spreadMethod: ['spreadMethod', null, 1 /* Attribute */],\n    startOffset: ['startOffset', null, 1 /* Attribute */],\n    stdDeviation: ['stdDeviation', null, 1 /* Attribute */],\n    stitchTiles: ['stitchTiles', null, 1 /* Attribute */],\n    surfaceScale: ['surfaceScale', null, 1 /* Attribute */],\n    systemLanguage: ['systemLanguage', null, 1 /* Attribute */],\n    tableValues: ['tableValues', null, 1 /* Attribute */],\n    targetX: ['targetX', null, 1 /* Attribute */],\n    targetY: ['targetY', null, 1 /* Attribute */],\n    textLength: ['textLength', null, 1 /* Attribute */],\n    viewBox: ['viewBox', null, 1 /* Attribute */],\n    viewTarget: ['viewTarget', null, 1 /* Attribute */],\n    xChannelSelector: ['xChannelSelector', null, 1 /* Attribute */],\n    yChannelSelector: ['yChannelSelector', null, 1 /* Attribute */],\n    zoomAndPan: ['zoomAndPan', null, 1 /* Attribute */],\n};\nvar attributeOnlyRx = /-/, deepAttrRx = /^style-/, isAttrOnlyField = function (field) { return attributeOnlyRx.test(field) && !deepAttrRx.test(field); }, propOnlyRx = /^(on|style)/, isPropOnlyField = function (field) { return propOnlyRx.test(field); }, propPartRx = /[a-z][A-Z]/g, getAttrName = function (field) { return field.replace(propPartRx, function (m) { return m[0] + '-' + m[1]; }).toLowerCase(); }, jsxEventPropRx = /^on[A-Z]/, attrPartRx = /\\-(?:[a-z]|$)/g, getPropName = function (field) {\n    var prop = field.replace(attrPartRx, function (m) { return m.length === 1 ? '' : m[1].toUpperCase(); });\n    return jsxEventPropRx.test(prop) ? prop.toLowerCase() : prop;\n}, deepPropRx = /^(style)([A-Z])/, buildPropData = function (prop) {\n    var m = deepPropRx.exec(prop);\n    return m ? [m[2].toLowerCase() + prop.substr(m[0].length), m[1], 0 /* Property */] : [prop, null, 0 /* Property */];\n}, attrNamespaces = {\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n}, attrNamespaceRx = new RegExp(\"^(\" + Object.keys(attrNamespaces).join('|') + \")-(.*)\"), buildAttrData = function (attr) {\n    var m = attrNamespaceRx.exec(attr);\n    return m ? [m[2], attrNamespaces[m[1]], 1 /* Attribute */] : [attr, null, 1 /* Attribute */];\n};\nexport var getFieldData = function (field, svg) {\n    var cache = svg ? svgFieldCache : htmlFieldCache, cached = cache[field];\n    if (cached)\n        return cached;\n    var attr = svg && !isPropOnlyField(field)\n        || !svg && isAttrOnlyField(field), name = attr ? getAttrName(field) : getPropName(field);\n    if (name !== field && (cached = cache[name]))\n        return cached;\n    var data = attr ? buildAttrData(name) : buildPropData(name);\n    return cache[field] = data;\n};\n","/**\n * hashSignal.ts by Adam Haile. From surplus-realword:\n * https://github.com/adamhaile/surplus-realworld/blob/master/src/app/hashSignal.ts\n */\n\nimport S, { DataSignal } from 's-js';\n\n/**\n * Construct a data signal that tracks the hash value in the browser's location.\n * \n * Setting the signal changes the hash and vice-versa.\n * \n * Browser location can be set two ways: a replace or an assign. We represent\n * that as two data signals, hash() and hash.change().  The first tracks all changes \n * to the location, whether a replace or an assign, while the second tracks only \n * assigns.  Setting hash() replaces the location, setting change() assigns a new one.\n */\nexport interface HashSignal extends DataSignal<string> {\n    change : DataSignal<string>\n}\nexport const HashSignal = () => {\n    const \n        // we need to detect sets to the data signals so that we can also change the \n        // window location, so we make underlying data signals and wrap them\n        _hash = S.data(window.location.hash), \n        _change = S.data(window.location.hash),\n        // setting hash also replaces current location in browser\n        hash = ((loc? : string) => loc === undefined ? _hash() : set(loc, false)) as HashSignal,\n        // setting change also sets hash and assigns a new location in browser\n        change = ((loc? : string) => loc === undefined ? _change() : set(loc, true)) as DataSignal<string>,\n        set = (loc: string, isChange : boolean) => S.freeze(() => {\n            _hash(loc);\n            if (isChange) _change(loc);\n            window.location[isChange ? 'assign' : 'replace'](loc);\n            return loc;\n        });\n\n    hash.change = change;\n\n    // change from the other direction: set signals when a hashchange event occurs\n    const onHashChange = () => S.freeze(() => { \n        if ((window.location.hash || '#') !== _hash())\n            _hash(_change(window.location.hash));\n    });\n    window.addEventListener('hashchange', onHashChange);\n    S.cleanup(() => window.removeEventListener('hashchange', onHashChange));\n\n    return hash;\n};\n","const\n    RGBColor = /^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i,\n    RRGGBBColor = /^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i;\n\nexport class RGB {\n    // All numbers from 0 to 255\n    constructor(public r : number, public g : number, public b : number) {}\n\n    isValid() {\n        return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255;\n    }\n\n    toString(opts : { hideHash? : boolean } = {}) {\n        return this.isValid() ?\n            (opts.hideHash ? '' : '#') + (toHex(this.r) + toHex(this.g) + toHex(this.b)).toLowerCase() :\n            'INVALID';\n    }\n\n    /**\n     * Parse a string in #RGB or #RRGGBB format into an RGB color.\n     * If input is invalid, returns null.\n     * @param str A string in #RGB or #RRGGBB format.\n     */\n    static parse(str : string) {\n        const RGBMatch = str.match(RGBColor);\n        if (RGBMatch) {\n            return new RGB(\n                // Concatenate each character with itself\n                parseHex(RGBMatch[1] + RGBMatch[1]),\n                parseHex(RGBMatch[2] + RGBMatch[2]),\n                parseHex(RGBMatch[3] + RGBMatch[3])\n            );\n        }\n\n        const RRGGBBMatch = str.match(RRGGBBColor);\n        if (RRGGBBMatch) {\n            return new RGB(\n                parseHex(RRGGBBMatch[1]),\n                parseHex(RRGGBBMatch[2]),\n                parseHex(RRGGBBMatch[3])\n            );\n        }\n\n        return null;\n    }\n\n    static eq(rgb1 : RGB, rgb2 : RGB) {\n        return rgb1.r === rgb2.r && rgb1.g === rgb2.g && rgb1.b === rgb2.b;\n    }\n\n    static invalid() {\n        return new RGB(NaN, NaN, NaN);\n    }\n}\n\nfunction parseHex(str : string) : number {\n    return parseInt(str, 16);\n}\n\nfunction toHex(num : number) : string {\n    return ('00' + num.toString(16)).substr(-2);\n}\n","import { RGB } from './colorHandling/rgb';\nimport { DeepPartial, AppOptions } from './app';\n\n/**\n * Parse query string into App options\n * @param query The query string, with or without leading '?'\n */\nexport function parseQueryString(query : string) : DeepPartial<AppOptions> {\n    const\n        params = new URLSearchParams(query),\n        cRe = params.get('c_re') ? +params.get('c_re')! : null,\n        cIm = params.get('c_im') ? +params.get('c_im')! : null,\n        ctrRe = params.get('ctr_re') ? +params.get('ctr_re')! : null,\n        ctrIm = params.get('ctr_im') ? +params.get('ctr_im')! : null,\n        zoom = params.get('zoom') ? +params.get('zoom')! : null,\n        colorIn = params.get('color_in') ? RGB.parse(params.get('color_in')!) : null,\n        colorOut = params.get('color_out') ? RGB.parse(params.get('color_out')!) : null,\n        res = params.get('res') ? +params.get('res')! : null,\n        iter = params.get('iter') ? +params.get('iter')! : null,\n        rad = params.get('rad') ? +params.get('rad')! : null;\n\n    return {\n        canvas: {\n            center: {\n                re: ctrRe !== null ? ctrRe : undefined,\n                im: ctrIm !== null ? ctrIm : undefined\n            },\n            zoom: zoom !== null && zoom > 0 ? zoom : undefined,\n            resolution: res !== null && res > 0 ? res : undefined\n        },\n        escapeTime: {\n            c: {\n                re: cRe !== null ? cRe : undefined,\n                im: cIm !== null ? cIm : undefined\n            },\n            maxIter: iter !== null && iter > 0 ? iter : undefined,\n            escapeRadius: rad !== null && rad > 0 ? rad : undefined\n        },\n        imager: {\n            includedColor: colorIn || undefined,\n            excludedColor: colorOut || undefined\n        }\n    };\n}\n\n/**\n * Format the query string for the given App options\n * @returns The formatted query string without leading '?'\n */\nexport function formatQueryString(opts : AppOptions) {\n    const params = new URLSearchParams();\n\n    params.set('c_re', '' + opts.escapeTime.c.re);\n    params.set('c_im', '' + opts.escapeTime.c.im);\n    params.set('ctr_re', '' + opts.canvas.center.re);\n    params.set('ctr_im', '' + opts.canvas.center.im);\n    params.set('zoom', '' + opts.canvas.zoom);\n    params.set('color_in', opts.imager.includedColor.toString({ hideHash: true }));\n    params.set('color_out', opts.imager.excludedColor.toString({ hideHash: true }));\n    params.set('res', '' + opts.canvas.resolution);\n    params.set('iter', '' + opts.escapeTime.maxIter);\n    params.set('rad', '' + opts.escapeTime.escapeRadius);\n\n    return params.toString();\n}\n","import S from 's-js';\nimport { IComplex } from '../shared/IComplex';\nimport { ICanvasConfig, ICanvasRect } from '../shared/config';\n\nexport interface CanvasMgrOptions {\n    /**\n     * Center of the displayed canvas in complex coordinates.\n     */\n    center : IComplex;\n\n    /**\n     * Number of browser px per change of 1 in complex coordinates, in either real or imaginary axis.\n     */\n    zoom : number;\n\n    /**\n     * Number of logical px per browser px, in either real or imaginary axis.\n     */\n    resolution : number;\n}\n\n/**\n * The size of a data chunk in logical pixels.\n * Influences the size of the data buffers that get shuttled back and forth\n * to the worker thread and populated via WASM.\n */\nexport const ChunkSizePx = {\n    height: 1 << 5,\n    width: 1 << 5\n};\n\n// CanvasMgr is concerned with setting canvas size and position, translating btwn different coordinate systems.\nexport type CanvasMgr = ReturnType<typeof CanvasMgr>;\nexport function CanvasMgr(opts : CanvasMgrOptions) {\n    const\n        // Size of canvas in browser px\n        canvasSizeBrowserPx = {\n            width:  S.value<number | null>(null),\n            height: S.value<number | null>(null)\n        },\n        // Number of browser px per change of 1 in complex coordinates\n        zoom = S.value(opts.zoom),\n        // Ratio of logical px to browser px. Higher means more logical px per browser px.\n        resolution = S.value(opts.resolution),\n        // Center of the displayed canvas in complex coordinates\n        center = {\n            re: S.value(opts.center.re),\n            im: S.value(opts.center.im)\n        },\n        // Initialize origin to match center, then reset to center whenever zoom or resolution change\n        originTrigger = () => {\n            zoom();\n            resolution();\n        },\n        // Origin in the sense of WASM's Canvas struct.\n        // Not necessarily the center of the displayed canvas.\n        // Instead, the complex coordinates that correspond to ChunkId 0 + 0i.\n        origin = {\n            re: S.on(originTrigger, () => center.re()),\n            im: S.on(originTrigger, () => center.im())\n        },\n        // Bottom right - top left in complex coordinates for any given chunk\n        chunkDelta = {\n            // Conventional orientation -- real axis increases from left to right, imaginary axis decreases from top to bottom\n            re: () =>  ChunkSizePx.width  / zoom() / resolution(),\n            im: () => -ChunkSizePx.height / zoom() / resolution()\n        },\n        canvasConfig = S<ICanvasConfig>(() => ({\n            chunkDelta: {\n                re: chunkDelta.re(),\n                im: chunkDelta.im()\n            },\n            origin: {\n                re: origin.re(),\n                im: origin.im()\n            }\n        })),\n        rect = RectCalculations({\n            canvasSizeBrowserPx,\n            resolution,\n            center,\n            origin,\n            chunkDelta\n        });\n\n    return {\n        canvasSizeBrowserPx,\n        resolution,\n        zoom,\n        center,\n        origin,\n        chunkDelta,\n        canvasConfig,\n        rect,\n        currentOpts,\n        updateOpts\n    };\n\n    function currentOpts() : CanvasMgrOptions {\n        return {\n            center: {\n                re: center.re(),\n                im: center.im()\n            },\n            zoom: zoom(),\n            resolution: resolution()\n        };\n    }\n\n    function updateOpts(opts : CanvasMgrOptions) {\n        S.freeze(() => S.sample(() => {\n            center.re(opts.center.re);\n            center.im(opts.center.im);\n            zoom(opts.zoom);\n            resolution(opts.resolution);\n        }));\n    }\n}\n\nexport interface ComplexSignals {\n    re : () => number;\n    im : () => number;\n}\n\n// Responsible for computing the current ICanvasRect\nexport type RectCalculations = ReturnType<typeof RectCalculations>;\nexport function RectCalculations({\n    canvasSizeBrowserPx,\n    resolution,\n    center,\n    origin,\n    chunkDelta\n} : {\n    canvasSizeBrowserPx : {\n        width  : () => number | null,\n        height : () => number | null\n    },\n    resolution : () => number,\n    center : ComplexSignals,\n    origin : ComplexSignals,\n    chunkDelta : ComplexSignals\n}) {\n    const\n        // Size of canvas in (possibly fractional) logical px\n        canvasSizeLogicalPx = {\n            width:  () => canvasSizeBrowserPx.width()  === null ? null : canvasSizeBrowserPx.width()!  * resolution(),\n            height: () => canvasSizeBrowserPx.height() === null ? null : canvasSizeBrowserPx.height()! * resolution()\n        },\n        // center - origin in (possibly fractional) chunks\n        centerFromOriginChunks = {\n            re: () => (center.re() - origin.re()) / chunkDelta.re(),\n            im: () => (center.im() - origin.im()) / chunkDelta.im()\n        },\n        // origin - top left of canvas in (possibly fractional) logical px\n        originOffsetPx = {\n            x: () => canvasSizeLogicalPx.width()  === null ? null : -centerFromOriginChunks.re() * ChunkSizePx.width  + canvasSizeLogicalPx.width()!  / 2,\n            y: () => canvasSizeLogicalPx.height() === null ? null : -centerFromOriginChunks.im() * ChunkSizePx.height + canvasSizeLogicalPx.height()! / 2\n        },\n        // top left of displayed canvas, specified in chunks from the origin\n        topLeftChunks = {\n            re: () => originOffsetPx.x() === null ? null : -originOffsetPx.x()! / ChunkSizePx.width,\n            im: () => originOffsetPx.y() === null ? null : -originOffsetPx.y()! / ChunkSizePx.height\n        },\n        // bottom right of displayed canvas, specified in chunks from the origin\n        bottomRightChunks = {\n            re: () => topLeftChunks.re() === null || canvasSizeLogicalPx.width()  === null ? null :\n                topLeftChunks.re()! + canvasSizeLogicalPx.width()!  / ChunkSizePx.width,\n            im: () => topLeftChunks.im() === null || canvasSizeLogicalPx.height() === null ? null :\n                topLeftChunks.im()! + canvasSizeLogicalPx.height()! / ChunkSizePx.height\n        },\n        // Current canvas rect, specified in chunks.\n        // Essentially, round up the size of the canvas in browser px to the nearest whole chunk.\n        canvasRect = S<ICanvasRect | null>(() => {\n            if (topLeftChunks.re() === null || topLeftChunks.im() === null || bottomRightChunks.re() === null || bottomRightChunks.im() === null) return null;\n            const\n                topLeft = {\n                    re: Math.floor(topLeftChunks.re()!),\n                    im: Math.floor(topLeftChunks.im()!)\n                };\n\n            return {\n                topLeft,\n                widthChunks:  Math.ceil(bottomRightChunks.re()!) - topLeft.re,\n                heightChunks: Math.ceil(bottomRightChunks.im()!) - topLeft.im\n            };\n        });\n\n    return {\n        canvasSizeLogicalPx,\n        originOffsetPx,\n        canvasRect\n    };\n}\n","import S, { DataSignal } from 's-js';\nimport { IComplex } from '../../shared/IComplex';\n\nexport type SimpleMapFn<T, U>   = (data : T, chunkId : IComplex) => U;\nexport type ReducingMapFn<T, U> = (data : T, chunkId : IComplex, prev : U) => U;\nexport type SeedFactory<T>      = (chunkId : IComplex) => T;\n\nexport interface IBundle<T> {\n    /**\n     * Get a function that returns the value currently held at the given ChunkId.\n     */\n    get(chunkId : IComplex) : () => T;\n\n    /**\n     * Produce a new bundle by applying a function to each chunk of the current bundle.\n     */\n    map<U>(fn : SimpleMapFn<T, U>) : IBundle<U>;\n    map<U>(fn : ReducingMapFn<T, U>, seedFactory : SeedFactory<U>) : IBundle<U>;\n\n    /**\n     * \"Crack\" the bundle by returning all data currently held within it.\n     * Useful for, e.g., reclaiming memory.\n     * Calling code should assume that this does NOT subscribe to any signals held w/in the bundle.\n     * Implementations should use S.sample as needed to guarantee this.\n     */\n    crack() : T[];\n}\n\nabstract class Bundle<T> implements IBundle<T> {\n    abstract get(chunkId : IComplex) : () => T;\n    protected abstract currentSlots() : (() => T)[];\n\n    map<U>(fn : SimpleMapFn<T, U>) : IBundle<U>;\n    map<U>(fn : ReducingMapFn<T, U>, seedFactory : SeedFactory<U>) : IBundle<U>;\n    map<U>(fn : ReducingMapFn<T, U>, seedFactory? : SeedFactory<U>) : IBundle<U> {\n        if (seedFactory === undefined) return new MappedBundle(this, fn as SimpleMapFn<T, U>);\n        return new MappedBundle(this, fn, seedFactory);\n    }\n\n    crack() {\n        return this.currentSlots().map(slot => S.sample(slot));\n    }\n}\n\nexport class DataBundle<T> extends Bundle<T | null> {\n    private readonly chunks : Map<string, DataSignal<T | null>>;\n\n    constructor() {\n        super();\n        this.chunks = new Map<string, DataSignal<T | null>>();\n    }\n\n    get(chunkId : IComplex) {\n        const\n            key = chunkIdKey(chunkId),\n            chunk = this.chunks.get(key) || S.data(null);\n        this.chunks.set(key, chunk);\n        return chunk;\n    }\n\n    protected currentSlots() {\n        const slots = [] as (() => T | null)[];\n        this.chunks.forEach(c => slots.push(c));\n        return slots;\n    }\n}\n\ninterface MappedBundleChunk<T> {\n    dispose : () => void;\n    value : () => T;\n}\n\nexport class MappedBundle<T, U> extends Bundle<U> {\n    private readonly chunks : Map<string, MappedBundleChunk<U>>;\n\n    constructor(original : IBundle<T>, mapFn : SimpleMapFn<T, U>);\n    constructor(original : IBundle<T>, mapFn : ReducingMapFn<T, U>, seedFactory : SeedFactory<U>);\n    constructor(\n        private readonly original : IBundle<T>,\n        private readonly mapFn : ReducingMapFn<T, U>,\n        private readonly seedFactory? : SeedFactory<U>\n    ) {\n        super();\n        this.chunks = new Map<string, MappedBundleChunk<U>>();\n\n        // All computations created by get below become \"adoptive\" children of whatever\n        // computation/root constructed this MappedBundle.\n        S.cleanup(() => {\n            this.chunks.forEach(({ dispose }) => dispose());\n        });\n    }\n\n    get(chunkId : IComplex) {\n        const key = chunkIdKey(chunkId);\n        let chunk = this.chunks.get(key);\n        if (!chunk) {\n            let dispose! : () => void;\n            const\n                upstream = this.original.get(chunkId),\n                value = S.root(_dispose => {\n                    dispose = _dispose;\n                    return this.seedFactory ?\n                        S(prev => (this.mapFn as ReducingMapFn<T, U>)(upstream(), chunkId, prev), this.seedFactory!(chunkId)) :\n                        S(() =>   (this.mapFn as SimpleMapFn<T, U>)  (upstream(), chunkId));\n                });\n            chunk = { dispose, value };\n            this.chunks.set(key, chunk);\n        }\n        return chunk.value;\n    }\n\n    protected currentSlots() {\n        const slots = [] as (() => U)[];\n        this.chunks.forEach(c => slots.push(c.value));\n        return slots;\n    }\n}\n\nfunction chunkIdKey(chunkId : IComplex) {\n    return `${chunkId.re}+${chunkId.im}i`;\n}\n","import S from 's-js';\nimport { IEscapeTimeConfig, ICanvasConfig, ICanvasRect } from '../shared/config';\nimport { IWorkerInitMsg, IWorkerResetMsg, IAddJobsMsg, MessageToMain } from '../shared/messages';\nimport { MemoryPool } from '../shared/memoryPool';\nimport { DataBundle, IBundle } from './lib/dataBundle';\nimport { CanvasMgr, ChunkSizePx } from './canvasMgr';\n\nexport interface EscapeTimeRunnerOptions extends IEscapeTimeConfig {}\n\n// EscapeTimeRunner is the layer the instantiates and calls workers and populates result data\nexport type EscapeTimeRunner = ReturnType<typeof EscapeTimeRunner>;\nexport function EscapeTimeRunner(canvasMgr : CanvasMgr, workerUrl : string, opts : EscapeTimeRunnerOptions) {\n    const\n        c = {\n            re: S.value(opts.c.re),\n            im: S.value(opts.c.im)\n        },\n        maxIter = S.value(opts.maxIter),\n        escapeRadius = S.value(opts.escapeRadius),\n        // EscapeTime data is 2 bytes per logical pixel\n        pool = new MemoryPool(ChunkSizePx.width * ChunkSizePx.height * 2),\n        resetMsgData = S<{ escapeTime : IEscapeTimeConfig, canvas : ICanvasConfig }>(() => ({\n            escapeTime: {\n                c: {\n                    re: c.re(),\n                    im: c.im()\n                },\n                maxIter: maxIter(),\n                escapeRadius: escapeRadius()\n            },\n            canvas: canvasMgr.canvasConfig()\n        })),\n        dataGen = S.on(resetMsgData, count => count + 1, -1),\n        resultData = S(() => {\n            resetMsgData();\n\n            const data = new DataBundle<Uint16Array>();\n\n            // Recycle buffers when constructing a new data bundle\n            S.cleanup(() => data.crack().forEach(chunk => {\n                chunk && pool.push(chunk.buffer);\n            }));\n\n            // Also recycle buffers if a chunk is updated with a new buffer or set to null\n            data.map<Uint16Array | null>((curr, chunkId, prev) => {\n                if (prev && curr !== prev) pool.push(prev.buffer);\n                return curr;\n            }, () => null);\n\n            return data;\n        });\n\n    const worker = new Worker(workerUrl);\n\n    worker.onmessage = ev => {\n        const msg = ev.data as MessageToMain;\n\n        if (msg.type === 'startup-failure') {\n            throw new Error(msg.err);\n        } else if (msg.type === 'chunk-update') {\n            // Before we commit data to the model, make sure the message's dataGen matches our current\n            if (msg.dataGen === dataGen()) {\n                resultData().get(msg.chunkId)(new Uint16Array(msg.data));\n            }\n        }\n    };\n\n    const workerInit : IWorkerInitMsg = {\n        type: 'worker-init',\n        worker: {\n            chunkSizePx: ChunkSizePx,\n            pauseInterval: 250\n        }\n    };\n    worker.postMessage(workerInit);\n\n    let instructionSeqNo = 0;\n\n    S(() => {\n        // Send worker a reset msg whenever our reset msg data changes...\n        const\n            resetMsg : IWorkerResetMsg = {\n                type: 'worker-reset',\n                escapeTime: resetMsgData().escapeTime,\n                canvas: resetMsgData().canvas,\n                dataGen: dataGen(),\n                seqNo: instructionSeqNo++\n            };\n        worker.postMessage(resetMsg);\n\n        // After that, send an add jobs msg whenever the canvas rect changes\n        S<ICanvasRect | null>(prev => {\n            const\n                // Recycle buffers back to the worker\n                returningBuffers = pool.drain(),\n                canvasRect = canvasMgr.rect.canvasRect(),\n                jobs =\n                    canvasRect ?\n                        prev ?\n                            excludedRects(canvasRect, prev) :\n                            [canvasRect] :\n                        [],\n                addJobsMsg : IAddJobsMsg = {\n                    type: 'add-jobs',\n                    jobs,\n                    seqNo: instructionSeqNo++,\n                    buffers: returningBuffers\n                };\n            worker.postMessage(addJobsMsg, returningBuffers);\n            return canvasRect;\n        }, null);\n    });\n\n    return {\n        c,\n        maxIter,\n        escapeRadius,\n        // Expose resultData as read-only\n        resultData: resultData as () => IBundle<Uint16Array | null>,\n        currentOpts,\n        updateOpts\n    };\n\n    function currentOpts() : EscapeTimeRunnerOptions {\n        return {\n            c: {\n                re: c.re(),\n                im: c.im()\n            },\n            maxIter: maxIter(),\n            escapeRadius: escapeRadius()\n        };\n    }\n\n    function updateOpts(opts : EscapeTimeRunnerOptions) {\n        S.freeze(() => {\n            c.re(opts.c.re);\n            c.im(opts.c.im);\n            maxIter(opts.maxIter);\n            escapeRadius(opts.escapeRadius);\n        });\n    }\n}\n\n/**\n * Get those portions of rect1 that are excluded by rect2, represented as a list of sub-rects.\n * In set notation, returns rect1 - rect2.\n */\nfunction excludedRects(rect1 : ICanvasRect, rect2 : ICanvasRect) : ICanvasRect[] {\n    const\n        results = [] as ICanvasRect[],\n        rectAbove : ICanvasRect = {\n            topLeft: rect1.topLeft,\n            widthChunks: rect1.widthChunks,\n            heightChunks: Math.max(Math.min(rect2.topLeft.im - rect1.topLeft.im, rect1.heightChunks), 0)\n        };\n    if (rectAbove.widthChunks * rectAbove.heightChunks > 0) results.push(rectAbove);\n\n    const\n        rect1Bottom = rect1.topLeft.im + rect1.heightChunks,\n        rect2Bottom = rect2.topLeft.im + rect2.heightChunks,\n        rectBelowHeight = Math.max(Math.min(rect1Bottom - rect2Bottom, rect1.heightChunks), 0),\n        rectBelow : ICanvasRect = {\n            topLeft: {\n                re: rect1.topLeft.re,\n                im: rect1Bottom - rectBelowHeight\n            },\n            widthChunks: rect1.widthChunks,\n            heightChunks: rectBelowHeight\n        };\n    if (rectBelow.widthChunks * rectBelow.heightChunks > 0) results.push(rectBelow);\n\n    const\n        rectAboveBottom = rectAbove.topLeft.im + rectAbove.heightChunks,\n        // We'll give rectAbove/rectBelow priority over rectLeft/rectRight so the returned rects are all disjoint.\n        // This gives the height available btwn the bottom of rectAbove and the top of rectBelow.\n        sideRectsHeight = Math.max(rectBelow.topLeft.im - rectAboveBottom, 0),\n        rectLeft : ICanvasRect = {\n            topLeft: {\n                re: rect1.topLeft.re,\n                im: rectAboveBottom\n            },\n            widthChunks: Math.max(Math.min(rect2.topLeft.re - rect1.topLeft.re, rect1.widthChunks), 0),\n            heightChunks: sideRectsHeight\n        };\n    if (rectLeft.widthChunks * rectLeft.heightChunks > 0) results.push(rectLeft);\n\n    const\n        rect1Right = rect1.topLeft.re + rect1.widthChunks,\n        rect2Right = rect2.topLeft.re + rect2.widthChunks,\n        rectRightWidth = Math.max(Math.min(rect1Right - rect2Right, rect1.widthChunks), 0),\n        rectRight : ICanvasRect = {\n            topLeft: {\n                re: rect1Right - rectRightWidth,\n                im: rectAboveBottom\n            },\n            widthChunks: rectRightWidth,\n            heightChunks: sideRectsHeight\n        };\n    if (rectRight.widthChunks * rectRight.heightChunks > 0) results.push(rectRight);\n\n    return results;\n}\n","import S from 's-js';\nimport { MemoryPool } from '../shared/memoryPool';\nimport { ChunkSizePx } from './canvasMgr';\nimport { EscapeTimeRunner } from './runner';\nimport { RGB } from './colorHandling/rgb';\nimport { linearFade } from './colorHandling/colorizers';\n\nexport interface ImagerOptions {\n    includedColor : RGB;\n    excludedColor : RGB;\n}\n\n// Imager translates the escape time data from EscapeTimeRunner into image data that can be rendered to an HTML canvas.\nexport type Imager = ReturnType<typeof Imager>;\nexport function Imager(runner : EscapeTimeRunner, opts : ImagerOptions) {\n    const\n        includedColor = S.value(opts.includedColor, RGB.eq),\n        excludedColor = S.value(opts.excludedColor, RGB.eq),\n        // TODO: Support other color functions, say from an enum?\n        colorizer = S(() => linearFade(includedColor(), excludedColor())),\n        // ImageData is 4 bytes per logical pixel\n        pool = new MemoryPool(ChunkSizePx.width * ChunkSizePx.height * 4),\n        imageData = S(() => {\n            const data = runner.resultData().map<ImageData | null>((chunk, chunkId, prevImage) => {\n                if (!chunk) {\n                    // Recycle previous image if chunk is being set to null\n                    if (prevImage) pool.push(prevImage.data.buffer);\n                    return null;\n                }\n\n                const\n                    _colorizer = colorizer(),\n                    maxIter = runner.maxIter(),\n                    // Modify previous image in place if we have one, otherwise acquire one from the pool\n                    imageChunk = prevImage ? prevImage.data : new Uint8ClampedArray(pool.acquire());\n\n                for (let i = 0; i / 4 < chunk.length && i < imageChunk.length; i += 4) {\n                    const magnitude = chunk[i / 4] / maxIter;\n                    imageChunk[i]     = _colorizer.r(magnitude);\n                    imageChunk[i + 1] = _colorizer.g(magnitude);\n                    imageChunk[i + 2] = _colorizer.b(magnitude);\n                    imageChunk[i + 3] = 255;\n                }\n\n                return new ImageData(imageChunk, ChunkSizePx.width, ChunkSizePx.height);\n            }, () => null);\n\n            // Recycle buffers when constructing a new mapped bundle\n            S.cleanup(() => data.crack().forEach(chunk => {\n                chunk && pool.push(chunk.data.buffer);\n            }));\n\n            return data;\n        });\n\n    return {\n        includedColor,\n        excludedColor,\n        imageData,\n        currentOpts,\n        updateOpts\n    };\n\n    function currentOpts() : ImagerOptions {\n        return {\n            includedColor: includedColor(),\n            excludedColor: excludedColor()\n        };\n    }\n\n    function updateOpts(opts : ImagerOptions) {\n        S.freeze(() => {\n            includedColor(opts.includedColor);\n            excludedColor(opts.excludedColor);\n        });\n    }\n}\n","import { RGB } from './rgb';\n\n/**\n * A function that maps from a magnitude in the range 0.0 to 1.0, with 0\n * meaning escaped immediately and 1 meaning hadn't escaped within max iters,\n * to a color value in the range 0 to 255.\n */\nexport type ColorChannelMapper = (magnitude : number) => number;\n\nexport interface Colorizer {\n    r : ColorChannelMapper;\n    g : ColorChannelMapper;\n    b : ColorChannelMapper;\n}\n\n/**\n * Color Julia set by linearly interpolating the provided colors.\n * @param included The color to use for points belonging to the Julia set\n * @param excluded The color to use for points maximally far from the Julia set.\n * In theory, this color will never actually be reached, just approached asymptotically.\n */\nexport function linearFade(included : RGB, excluded : RGB) : Colorizer {\n    return {\n        r: m => Math.round(m * included.r + (1 - m) * excluded.r),\n        g: m => Math.round(m * included.g + (1 - m) * excluded.g),\n        b: m => Math.round(m * included.b + (1 - m) * excluded.b)\n    };\n}\n","import S from 's-js';\nimport { RGB } from './colorHandling/rgb';\nimport { CanvasMgr } from './canvasMgr';\nimport { EscapeTimeRunner } from './runner';\nimport { Imager } from './imager';\n\n// Additional view state to support settings panel\nexport type Settings = ReturnType<typeof Settings>;\nexport function Settings(\n    canvasMgr : CanvasMgr,\n    runner : EscapeTimeRunner,\n    imager : Imager\n) {\n    const\n        color = ColorSettings(imager);\n\n    return {\n        color\n    };\n}\n\n\nexport interface ColorTheme {\n    name : string;\n    includedColor : RGB;\n    excludedColor : RGB;\n}\n\nexport const ColorThemes : ColorTheme[] = [{\n    name: 'Dark',\n    includedColor: RGB.parse('#f00')!,\n    excludedColor: RGB.parse('#000')!\n}, {\n    name: 'Light',\n    includedColor: RGB.parse('#0df')!,\n    excludedColor: RGB.parse('#fff')!\n}, {\n    name: 'High Contrast',\n    includedColor: RGB.parse('#f9ffff')!,\n    excludedColor: RGB.parse('#000007')!\n}];\n\nexport type ColorSettings = ReturnType<typeof ColorSettings>;\nexport function ColorSettings(imager : Imager) {\n    const\n        theme = S.value(S.sample(() => ColorThemes.find(t =>\n            RGB.eq(t.includedColor, imager.includedColor()) &&\n            RGB.eq(t.excludedColor, imager.excludedColor())\n        ) || null));\n\n    S.on(theme, () => {\n        if (theme()) {\n            imager.includedColor(theme()!.includedColor);\n            imager.excludedColor(theme()!.excludedColor);\n        }\n    }, undefined, true);\n\n    return {\n        theme\n    };\n}\n","import S from 's-js';\nimport { CanvasMgr, CanvasMgrOptions } from './canvasMgr';\nimport { EscapeTimeRunner, EscapeTimeRunnerOptions } from './runner';\nimport { Imager, ImagerOptions } from './imager';\nimport { RGB } from './colorHandling/rgb';\nimport { Settings } from './settings';\n\n// NOTE: This version isn't fully general but works for what we need.\n// For a fuller solution that also covers arrays, see https://stackoverflow.com/a/49936686\nexport type DeepPartial<T> = {\n    [K in keyof T]? : DeepPartial<T[K]>;\n};\n\nexport interface AppOptions {\n    canvas : CanvasMgrOptions;\n    escapeTime : EscapeTimeRunnerOptions;\n    imager : ImagerOptions;\n}\n\nconst CANVAS_DEFAULTS : CanvasMgrOptions = {\n    center: {\n        re: 0,\n        im: 0\n    },\n    zoom: 150,\n    resolution: 1.25\n};\n\nconst ESCAPE_TIME_DEFAULTS : EscapeTimeRunnerOptions = {\n    c: {\n        re: 0,\n        im: 0.8\n    },\n    maxIter: 50,\n    escapeRadius: 2\n};\n\nconst IMAGER_DEFAULTS : ImagerOptions = {\n    includedColor: new RGB(255, 0, 0),\n    excludedColor: new RGB(0, 0, 0)\n};\n\nfunction applyDefaults(opts : DeepPartial<AppOptions>) : AppOptions {\n    const\n        canvasOpts = opts.canvas || {},\n        centerOpts = canvasOpts.center || {},\n        escapeTimeOpts = opts.escapeTime || {},\n        cOpts = escapeTimeOpts.c || {},\n        imagerOpts = opts.imager || {},\n        includedColorOpts = imagerOpts.includedColor || {},\n        excludedColorOpts = imagerOpts.excludedColor || {};\n\n    return {\n        canvas: {\n            center: {\n                re: centerOpts.re !== undefined ? centerOpts.re : CANVAS_DEFAULTS.center.re,\n                im: centerOpts.im !== undefined ? centerOpts.im : CANVAS_DEFAULTS.center.im\n            },\n            zoom: canvasOpts.zoom !== undefined ? canvasOpts.zoom : CANVAS_DEFAULTS.zoom,\n            resolution: canvasOpts.resolution !== undefined ? canvasOpts.resolution : CANVAS_DEFAULTS.resolution\n        },\n        escapeTime: {\n            c: {\n                re: cOpts.re !== undefined ? cOpts.re : ESCAPE_TIME_DEFAULTS.c.re,\n                im: cOpts.im !== undefined ? cOpts.im : ESCAPE_TIME_DEFAULTS.c.im\n            },\n            maxIter: escapeTimeOpts.maxIter !== undefined ? escapeTimeOpts.maxIter : ESCAPE_TIME_DEFAULTS.maxIter,\n            escapeRadius: escapeTimeOpts.escapeRadius !== undefined ? escapeTimeOpts.escapeRadius : ESCAPE_TIME_DEFAULTS.escapeRadius\n        },\n        imager: {\n            includedColor: new RGB(\n                includedColorOpts.r !== undefined ? includedColorOpts.r : IMAGER_DEFAULTS.includedColor.r,\n                includedColorOpts.g !== undefined ? includedColorOpts.g : IMAGER_DEFAULTS.includedColor.g,\n                includedColorOpts.b !== undefined ? includedColorOpts.b : IMAGER_DEFAULTS.includedColor.b\n            ),\n            excludedColor: new RGB(\n                excludedColorOpts.r !== undefined ? excludedColorOpts.r : IMAGER_DEFAULTS.excludedColor.r,\n                excludedColorOpts.g !== undefined ? excludedColorOpts.g : IMAGER_DEFAULTS.excludedColor.g,\n                excludedColorOpts.b !== undefined ? excludedColorOpts.b : IMAGER_DEFAULTS.excludedColor.b\n            )\n        }\n    };\n}\n\nexport type App = ReturnType<typeof App>;\nexport function App(workerUrl : string, opts : DeepPartial<AppOptions>) {\n    const\n        { canvas: canvasMgrOpts, escapeTime: escapeTimeOpts, imager: imagerOpts } = applyDefaults(opts),\n        canvasMgr = CanvasMgr(canvasMgrOpts),\n        runner = EscapeTimeRunner(canvasMgr, workerUrl, escapeTimeOpts),\n        imager = Imager(runner, imagerOpts),\n        settings = Settings(canvasMgr, runner, imager);\n\n    return {\n        canvasMgr,\n        runner,\n        imager,\n        settings,\n        currentOpts,\n        updateOpts\n    };\n\n    function currentOpts() : AppOptions {\n        return {\n            canvas: canvasMgr.currentOpts(),\n            escapeTime: runner.currentOpts(),\n            imager: imager.currentOpts()\n        };\n    }\n\n    function updateOpts(opts : DeepPartial<AppOptions>) {\n        const effective = applyDefaults(opts);\n        S.freeze(() => {\n            canvasMgr.updateOpts(effective.canvas);\n            runner.updateOpts(effective.escapeTime);\n            imager.updateOpts(effective.imager);\n        });\n    }\n}\n","import * as Surplus from 'surplus';\nimport { RGB } from './colorHandling/rgb';\nimport { App } from './app';\nimport { ColorThemes } from './settings';\n\nexport const SettingsView = ({ app } : { app : App }) =>\n    <div class=\"settings\">\n        <div class=\"setting setting-c\">\n            <label class=\"setting-label\">c</label>\n            <input\n                value={app.runner.c.re()}\n                onChange={e => app.runner.c.re(+e.currentTarget.value)}\n            />\n            {' + '}\n            <input\n                value={app.runner.c.im()}\n                onChange={e => app.runner.c.im(+e.currentTarget.value)}\n            />\n            {' i'}\n        </div>\n        <div class=\"setting setting-max-iter\">\n            <label class=\"setting-label\">Max. iter.</label>\n            <input\n                value={app.runner.maxIter()}\n                onChange={e => app.runner.maxIter(+e.currentTarget.value)}\n            />\n        </div>\n        <div class=\"setting setting-escape-radius\">\n            <label class=\"setting-label\">Escape Radius</label>\n            <input\n                value={app.runner.escapeRadius()}\n                onChange={e => app.runner.escapeRadius(+e.currentTarget.value)}\n            />\n        </div>\n        <ColorSelector app={app} />\n        <ZoomButtons app={app} />\n    </div>;\n\nconst ZoomButtons = ({ app } : { app : App }) =>\n    <div class=\"zoom-buttons\">\n        <span class=\"zoom-btn\" onClick={() => app.canvasMgr.zoom(app.canvasMgr.zoom() * 1.1)}>+</span>\n        <span class=\"zoom-btn\" onClick={() => app.canvasMgr.zoom(app.canvasMgr.zoom() * 0.9)}>-</span>\n    </div>;\n\nconst ColorSelector = ({ app } : { app : App }) =>\n    <div class=\"color-selector\">\n        <div class=\"setting\">\n            <label class=\"setting-label\">Theme</label>\n            <select class=\"color-dropdown\"\n                value={app.settings.color.theme() ? ColorThemes.indexOf(app.settings.color.theme()!) : -1}\n                onChange={e => app.settings.color.theme(ColorThemes[+e.currentTarget.value] || null)}\n            >\n                {ColorThemes.map((t, idx) =>\n                    <option value={idx}>{t.name}</option>\n                )}\n                <option value={-1}>Custom</option>\n            </select>\n        </div>\n        {!app.settings.color.theme() &&\n            <div class=\"color-custom\">\n                <div class=\"setting\">\n                    <label class=\"setting-label\">Color In</label>\n                    <input\n                        value={app.imager.includedColor().toString()}\n                        onChange={e => app.imager.includedColor(RGB.parse(e.currentTarget.value) || RGB.invalid())}\n                    />\n                </div>\n                <div class=\"setting\">\n                    <label class=\"setting-label\">Color Out</label>\n                    <input\n                        value={app.imager.excludedColor().toString()}\n                        onChange={e => app.imager.excludedColor(RGB.parse(e.currentTarget.value) || RGB.invalid())}\n                    />\n                </div>\n            </div>\n        }\n    </div>\n","import S, { DataSignal } from 's-js';\n\nexport interface DraftSignal<T> extends DataSignal<T> {\n    commit : () => void;\n    revert : () => void;\n}\n\nexport function draftSignal<T>(original : DataSignal<T>, eq? : (t1 : T, t2 : T) => boolean) : DraftSignal<T> {\n    const\n        effectiveEq = eq || ((t1, t2) => t1 === t2),\n        dirty = S.data(false),\n        // We'll enforce the invariant that whenever we set dirty to true,\n        // we also set written to a non-null value.\n        written = S.data<T | null>(null),\n        curr = () => dirty() ? written()! : original(),\n        draft = ((val? : T) => {\n            if (val === undefined) return curr();\n            const _curr = S.sample(curr);\n            if (!effectiveEq(val, _curr)) {\n                return S.freeze(() => {\n                    dirty(true);\n                    return written(val);\n                });\n            } else {\n                return _curr;\n            }\n        }) as DraftSignal<T>;\n\n    draft.commit = () => {\n        S.sample(() => {\n            if (dirty()) {\n                S.freeze(() => {\n                    original(written()!);\n                    dirty(false);\n                })\n            }\n        });\n    };\n\n    draft.revert = () => {\n        S.freeze(() => {\n            dirty(false);\n            written(null); // To free for GC\n        });\n    };\n\n    return draft;\n}\n","import S, { DataSignal } from 's-js';\nimport * as Surplus from 'surplus';\nimport * as cx from 'classnames';\nimport { IComplex } from '../shared/IComplex';\nimport { draftSignal, DraftSignal } from './lib/draftSignal';\nimport { ChunkSizePx, RectCalculations } from './canvasMgr';\nimport { App } from './app';\n\nexport const CanvasView = ({ app, mounted } : { app : App, mounted : () => boolean }) => {\n    const\n        drafts = CanvasDrafts(app),\n        panning = S.value(false);\n\n    return (\n        <canvas\n            class={cx('julia-canvas', { panning: panning() })}\n            fn0={reportsSizing(app, drafts, mounted)}\n            fn1={rendersJuliaImage(app, drafts)}\n            fn2={rendersOnZoomOut(app, drafts) as <U>(el : HTMLCanvasElement, prevBuffer : U | undefined) => any}\n            fn3={isDraggable(app, drafts, panning)}\n            fn4={isZoomable(app, drafts)}\n        />\n    );\n};\n\n// During transitions, we'll allow the view to \"float\" by having a canvas size,\n// zoom, or center different from the values defined in our model layer.\n// This enables smoother transitions when changing one of those values.\n// However, to be able to use the image data stored in the model layer, it's essential that\n// the view always use the same origin and chunkDelta as the model layer.\n// Those are needed to interpret the ChunkIds used by the model layer, and therefore can't \"float.\"\ntype CanvasDrafts = ReturnType<typeof CanvasDrafts>;\nconst CanvasDrafts = (app : App) => {\n    const\n        canvasSizeBrowserPx = {\n            width:  draftSignal(app.canvasMgr.canvasSizeBrowserPx.width),\n            height: draftSignal(app.canvasMgr.canvasSizeBrowserPx.height)\n        },\n        zoom   = draftSignal(app.canvasMgr.zoom),\n        center = {\n            re: draftSignal(app.canvasMgr.center.re),\n            im: draftSignal(app.canvasMgr.center.im)\n        },\n        // Treat resolution as a function of our draft zoom and the model's chunkDelta.\n        // NOTE: We'd expect to get the same answer if we instead used ChunkSizePx.height together with chunkDelta.im.\n        resolution = () => Math.abs(ChunkSizePx.width  / zoom() / app.canvasMgr.chunkDelta.re()),\n        rect = RectCalculations({\n            origin: app.canvasMgr.origin,\n            chunkDelta: app.canvasMgr.chunkDelta,\n            canvasSizeBrowserPx,\n            resolution,\n            center\n        });\n\n    return {\n        canvasSizeBrowserPx,\n        zoom,\n        center,\n        resolution,\n        rect\n    };\n}\n\nconst reportsSizing = (app : App, drafts : CanvasDrafts, mounted : () => boolean) => (canvas : HTMLCanvasElement) => {\n    if (mounted()) {\n        // On intial load, update model values directly\n        updateCanvasMgrSizing(app.canvasMgr.canvasSizeBrowserPx);\n\n        let timeout : number | undefined;\n\n        const onResize = () => {\n            // On resize, update draft values, then schedule an async commit\n            updateCanvasMgrSizing(drafts.canvasSizeBrowserPx);\n            if (timeout !== undefined) clearTimeout(timeout);\n            timeout = setTimeout(commit, 50);\n        };\n        window.addEventListener('resize', onResize);\n        S.cleanup(() => window.removeEventListener('resize', onResize));\n    }\n\n    function updateCanvasMgrSizing({ width, height } : {\n        width : (val : number) => void,\n        height : (val : number) => void\n    }) {\n        const rect = canvas.getBoundingClientRect();\n        width (rect.width );\n        height(rect.height);\n    }\n\n    function commit() {\n        drafts.canvasSizeBrowserPx.width .commit();\n        drafts.canvasSizeBrowserPx.height.commit();\n    }\n};\n\n// Default render method for all cases except while zooming out.\n// Zooming out gets its own specialized render method for performance reasons. See below.\nconst rendersJuliaImage = (app : App, drafts : CanvasDrafts) => (canvas : HTMLCanvasElement) => {\n    if (drafts.zoom() < app.canvasMgr.zoom()) return;\n\n    const\n        { rect } = drafts,\n        canvasSizeLogicalPx = rect.canvasSizeLogicalPx.width() === null || rect.canvasSizeLogicalPx.height() === null ? null : {\n            width: rect.canvasSizeLogicalPx.width()!,\n            height: rect.canvasSizeLogicalPx.height()!\n        };\n\n    if (!canvasSizeLogicalPx) return;\n\n    // Setting a canvas's width or height properties clears the canvas.\n    // So we need to redraw the Julia image after any change to the canvas's logical size.\n    // That's why we set width and height imperatively here, rather than using width and\n    // height attributes in the <canvas ... /> jsx element above. The surplus-generated computations\n    // for attributes don't give the needed control over timing, and lead to the canvas getting cleared\n    // occasionally during resizing.\n    canvas.width  = canvasSizeLogicalPx.width;\n    canvas.height = canvasSizeLogicalPx.height;\n\n    const ctx = canvas.getContext('2d')!;\n\n    S(() => {\n        const\n            originOffsetPx = rect.originOffsetPx.x() === null || rect.originOffsetPx.y() === null ? null : {\n                x: rect.originOffsetPx.x()!,\n                y: rect.originOffsetPx.y()!\n            },\n            canvasRect = rect.canvasRect();\n\n        if (!originOffsetPx || !canvasRect) return;\n\n        for (let row = 0; row < canvasRect.widthChunks; row++) {\n            for (let col = 0; col < canvasRect.heightChunks; col++) {\n                const\n                    chunkId = {\n                        re: canvasRect.topLeft.re + row,\n                        im: canvasRect.topLeft.im + col\n                    },\n                    topLeftCanvasCoords = {\n                        x: chunkId.re * ChunkSizePx.width  + originOffsetPx.x,\n                        y: chunkId.im * ChunkSizePx.height + originOffsetPx.y\n                    };\n\n                // Each canvas chunk gets its own computation that renders that chunk\n                S(() => {\n                    const imageData = app.imager.imageData().get(chunkId)();\n\n                    if (imageData) ctx.putImageData(imageData, topLeftCanvasCoords.x, topLeftCanvasCoords.y);\n                    else ctx.clearRect(topLeftCanvasCoords.x, topLeftCanvasCoords.y, ChunkSizePx.width, ChunkSizePx.height);\n                });\n            }\n        }\n    });\n};\n\n// Specialized render method just for zooming out.\n//\n// This overcomes the perf limitations of rendersJuliaImage for this case.\n// The simpler approach would be to use rendersJuliaImage in all cases including zoom out.\n// That'd work functionally, but it'd have poor perf on zoom out.\n// The problem is that as you zoomed out, the resolution would get higher and higher, meaning we'd need more chunks to fill the canvas,\n// and thus rendersJuliaImage would do more and more work on each zoom frame.\n// What's worse, more and more of the canvas would be empty, so we'd be spending most of that time computing data for a blank canvas.\n// This is the polar opposite of the zoom in case, where the more you zoom in, the lower the resolution gets and thus the less work needed\n// by rendersJuliaImage.\n//\n// So instead, we use the model layer to determine logical px, since the model layer has a stable resolution.\n// Then, to be able to use the model layer's existing imageData but still account for zooming out,\n// this implementation down samples from that imageData to fill the shrinking populated\n// area of the canvas. This means the amount of work decreases the more you zoom out.\nconst rendersOnZoomOut = (app : App, drafts : CanvasDrafts) => (canvas : HTMLCanvasElement, prevBuffer : ArrayBuffer | undefined) : ArrayBuffer | undefined => {\n    if (drafts.zoom() >= app.canvasMgr.zoom()) return;\n\n    const\n        // NOTE: Using the model layer to determine canvas px.\n        // We expect the draft layer to have higher resolution at this point,\n        // so choosing the lower resolution is a perf optimization b/c it means we don't have\n        // as many pixels to compute.\n        { rect, chunkDelta } = app.canvasMgr,\n        canvasSizeLogicalPx = rect.canvasSizeLogicalPx.width() === null || rect.canvasSizeLogicalPx.height() === null ? null : {\n            width: rect.canvasSizeLogicalPx.width()!,\n            height: rect.canvasSizeLogicalPx.height()!\n        },\n        originOffsetPx = rect.originOffsetPx.x() === null || rect.originOffsetPx.y() === null ? null : {\n            x: rect.originOffsetPx.x()!,\n            y: rect.originOffsetPx.y()!\n        };\n\n    if (!canvasSizeLogicalPx || !originOffsetPx) return;\n\n    // Ditto rendersJuliaImage about setting canvas width and height\n    canvas.width  = canvasSizeLogicalPx.width;\n    canvas.height = canvasSizeLogicalPx.height;\n\n    const ctx = canvas.getContext('2d')!;\n\n    const\n        // We'll shrink the entire canvasRect into a smaller target based on draft zoom\n        // Ratio of full zoom to draft zoom, which we're assuming to be smaller.\n        fullToDraftZoom = app.canvasMgr.zoom() / drafts.zoom(),\n        draftToFullZoom = 1 / fullToDraftZoom,\n        targetSizePx = {\n            width:  Math.floor(canvasSizeLogicalPx.width  * draftToFullZoom),\n            height: Math.floor(canvasSizeLogicalPx.height * draftToFullZoom)\n        },\n        // Point about which zoom is centered, in canvas px, reverse engineered by comparing the model layer's center with the draft center.\n        zoomCtr = {\n            x: (app.canvasMgr.center.re() - drafts.center.re()) * draftToFullZoom / (1 - draftToFullZoom) / chunkDelta.re() * ChunkSizePx.width  + canvasSizeLogicalPx.width  / 2,\n            y: (app.canvasMgr.center.im() - drafts.center.im()) * draftToFullZoom / (1 - draftToFullZoom) / chunkDelta.im() * ChunkSizePx.height + canvasSizeLogicalPx.height / 2\n        },\n        // Top left of target area in canvas px\n        targetCoords = {\n            x: Math.round(zoomCtr.x * (1 - draftToFullZoom)),\n            y: Math.round(zoomCtr.y * (1 - draftToFullZoom))\n        },\n        // Image data is 4 bytes per pixel\n        byteLength = targetSizePx.width * targetSizePx.height * 4,\n        // Re-use cached buffer if we have one\n        buffer = prevBuffer && prevBuffer.byteLength >= byteLength ? prevBuffer : new ArrayBuffer(byteLength),\n        targetImage = new ImageData(new Uint8ClampedArray(buffer, 0, byteLength), targetSizePx.width, targetSizePx.height);\n\n    // Avoid subscribing to the image data. We expect zoom out to be short-lived,\n    // and sampling avoids double renders in case you zoom out while the worker is still computing data.\n    S.sample(() => {\n        // Populate target image by down-sampling from chunk images\n        const\n            chunkId = { re: 0, im: 0 },\n            lastChunkId = { re: undefined as number | undefined, im: undefined as number | undefined };\n\n        // Cache fetched chunkImage and re-use as long as lastChunkId matches new chunkId.\n        // This is a crucial perf optimization, otherwise we get very bogged down looking up chunks in our DataBundle.\n        // The intuition is that we expect frequent runs of pixels that map to the same chunk.\n        let chunkImage = null as ImageData | null;\n\n        // Iterate target pixels. This means amount of work decreases as draft zoom decreases.\n        for (let i = 0; i < targetSizePx.width * targetSizePx.height; i++) {\n            const\n                // Add half a pixel so we're computing from the center of each pixel\n                rowPx = Math.floor(i / targetSizePx.width) + 0.5,\n                colPx = i % targetSizePx.width + 0.5,\n                // Identify the best source pixel for the given target pixel.\n                // source{Row|Col}Px -- coords of the source pixel relative to the origin\n                sourceRowPx = Math.round(fullToDraftZoom * (rowPx + targetCoords.y - zoomCtr.y) + zoomCtr.y - originOffsetPx.y - 0.5),\n                sourceColPx = Math.round(fullToDraftZoom * (colPx + targetCoords.x - zoomCtr.x) + zoomCtr.x - originOffsetPx.x - 0.5);\n\n            chunkId.re = Math.floor(sourceColPx / ChunkSizePx.width );\n            chunkId.im = Math.floor(sourceRowPx / ChunkSizePx.height);\n            chunkImage = chunkId.re === lastChunkId.re && chunkId.im === lastChunkId.im ? chunkImage : app.imager.imageData().get(chunkId)();\n            lastChunkId.re = chunkId.re;\n            lastChunkId.im = chunkId.im;\n\n            if (chunkImage) {\n                const\n                    rowOffset = sourceRowPx - chunkId.im * ChunkSizePx.height,\n                    colOffset = sourceColPx - chunkId.re * ChunkSizePx.width,\n                    bufferOffset = 4 * (rowOffset * ChunkSizePx.width + colOffset);\n\n                targetImage.data[4 * i    ] = chunkImage.data[bufferOffset    ];\n                targetImage.data[4 * i + 1] = chunkImage.data[bufferOffset + 1];\n                targetImage.data[4 * i + 2] = chunkImage.data[bufferOffset + 2];\n                targetImage.data[4 * i + 3] = chunkImage.data[bufferOffset + 3];\n            } else {\n                // Set alpha to 0 to clear this pixel. Don't care about r,g, or b.\n                targetImage.data[4 * i + 3] = 0;\n            }\n        }\n    });\n\n    ctx.clearRect(0, 0, canvasSizeLogicalPx.width, canvasSizeLogicalPx.height);\n    ctx.putImageData(targetImage, targetCoords.x, targetCoords.y);\n\n    // Return buffer to cache for next zoom frame.\n    return buffer;\n}\n\nconst isDraggable = (app : App, drafts : CanvasDrafts, panning : DataSignal<boolean>) => (canvas : HTMLCanvasElement) => {\n    let lastClientX = 0, lastClientY = 0, timeout : number | undefined;\n\n    const\n        mouseDown = (e : MouseEvent) => {\n            // Avoid triggering on right click, ctrl-click, or any other modified click\n            if (e.button === 0 /* Main button */ && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {\n                panning(true);\n                lastClientX = e.clientX;\n                lastClientY = e.clientY;\n            }\n        },\n        mouseMove = (e : MouseEvent) => {\n            if (panning()) {\n                // Note reversed directions. Moving mouse to the left moves center real coord to the RIGHT, ditto for imaginary coord.\n                const\n                    deltaX = lastClientX - e.clientX,\n                    deltaY = lastClientY - e.clientY;\n\n                lastClientX = e.clientX;\n                lastClientY = e.clientY;\n\n                S.freeze(() => S.sample(() => {\n                    drafts.center.re(drafts.center.re() + deltaX * drafts.resolution() / ChunkSizePx.width  * app.canvasMgr.chunkDelta.re());\n                    drafts.center.im(drafts.center.im() + deltaY * drafts.resolution() / ChunkSizePx.height * app.canvasMgr.chunkDelta.im());\n                }));\n\n                if (timeout === undefined) timeout = setTimeout(commit, 50);\n            }\n        },\n        mouseUp = () => panning(false),\n        commit = () => {\n            timeout = undefined;\n            S.freeze(() => {\n                drafts.center.re.commit();\n                drafts.center.im.commit();\n            });\n        };\n\n    canvas.addEventListener('mousedown', mouseDown);\n    document.addEventListener('mousemove', mouseMove);\n    document.addEventListener('mouseup'  , mouseUp  );\n    S.cleanup(() => {\n        canvas.removeEventListener('mousedown', mouseDown);\n        document.removeEventListener('mousemove', mouseMove);\n        document.removeEventListener('mouseup'  , mouseUp  );\n    });\n};\n\n// Constants and isZoomable logic below adapted from mapbox-gl-js, Copyright (c) 2016, Mapbox\n// See https://github.com/mapbox/mapbox-gl-js/blob/0de15ab814dcd754d8923f0c1b4e7304a6b088a4/src/ui/handler/scroll_zoom.js\nconst\n    // For converting btwn DOM_DELTA_LINE and DOM_DELTA_PIXEL\n    PX_PER_DOM_DELTA_LINE = 40,\n    // Linear scale factor for sensitivity. Higher means wheel gestures are more sensitive across the board.\n    ZOOM_SENSITIVITY = 1 / 450,\n    // Exponent to apply to sensitivity. Set to a number btwn 0 and 1 to fine-tune how sensitivity varies by gesture speed.\n    ZOOM_SENSITIVITY_EXP = 0.8,\n    // Threshold speed to count a gesture as intentional. We'll ignore below this.\n    MIN_DELTA_PER_MS = 0.5,\n    // Duration of a zoom frame\n    ZOOM_FRAME_RATE_MS = 10,\n    // Period of quiet before we commit zoom changes to the model layer.\n    // This MUST be larger than ZOOM_FRAME_RATE_MS.\n    ZOOM_UPDATE_DELAY_MS = 100;\n\nconst isZoomable = (app : App, drafts : CanvasDrafts) => (canvas : HTMLCanvasElement) => {\n    let delta = 0,\n        // The center for the current zoom in complex coords\n        zoomCtr : IComplex | undefined,\n        frameTimeout : number | undefined,\n        commitTimeout : number | undefined;\n\n    const\n        onMouseWheel = (e : WheelEvent) => {\n            // Default is to zoom the entire browser window\n            e.preventDefault();\n\n            // DOM_DELTA_LINE occurs on FF using true mouse wheel (as opposed to trackpad).\n            // TODO: DOM_DELTA_PAGE? Sounds like this is Windows only and depends on mouse settings.\n            delta += e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * PX_PER_DOM_DELTA_LINE : e.deltaY;\n\n            if (zoomCtr === undefined) {\n                // Center zoom around initial location of wheel gesture.\n                const\n                    rect = canvas.getBoundingClientRect(),\n                    // Location of zoom relative to center of canvas in browser px\n                    zoomLocX = e.clientX - (rect.left + rect.width  / 2),\n                    zoomLocY = e.clientY - (rect.top  + rect.height / 2);\n                // Compute complex coords of zoom location from known complex coords of center of canvas\n                // Recall zoom measures browser px per complex unit.\n                zoomCtr = {\n                    re: drafts.center.re() + Math.sign(app.canvasMgr.chunkDelta.re()) * zoomLocX / drafts.zoom(),\n                    im: drafts.center.im() + Math.sign(app.canvasMgr.chunkDelta.im()) * zoomLocY / drafts.zoom()\n                };\n            }\n\n            // Chunking wheel events into discrete \"frames\" helps smooth over timing differences btwn platforms/browsers/devices,\n            // and also gives us more chance to distinguish intentional zooms from accidental \"blips\".\n            if (frameTimeout === undefined) frameTimeout = setTimeout(onZoomFrame, ZOOM_FRAME_RATE_MS);\n            if (commitTimeout !== undefined) clearTimeout(commitTimeout);\n            commitTimeout = setTimeout(commit, ZOOM_UPDATE_DELAY_MS);\n        },\n        onZoomFrame = () => {\n            const\n                _delta = delta;\n\n            delta = 0;\n            frameTimeout = undefined;\n\n            // Zooming causes a repaint of the canvas. So enforce a min delta to avoid repaints due to\n            // accidental \"blips\".\n            if (Math.abs(_delta / ZOOM_FRAME_RATE_MS) >= MIN_DELTA_PER_MS) {\n                const\n                    // Use modified sigmoid to calculate scale factor. Idea of using sigmoid comes from Mapbox.\n                    // Adding an extra ZOOM_SENSITIVITY_EXP lets us compress the sensitivity range slightly by\n                    // making fast wheel gestures slightly more sensitive and slow wheel gestures slightly less sensitive.\n                    // In the extreme, if ZOOM_SENSITIVITY_EXP is set to 0, then the scale factor is constant across gesture speeds.\n                    exp = Math.pow(Math.abs(ZOOM_SENSITIVITY * _delta), ZOOM_SENSITIVITY_EXP),\n                    scale = Math.pow(2 / (1 + Math.exp(-exp)), _delta <= 0 ? 1 : -1);\n\n                S.freeze(() => {\n                    drafts.zoom(drafts.zoom() * scale);\n                    // Re-center canvas so that zoom center stays in same location proportional to location and dimensions of the canvas.\n                    drafts.center.re((1 - 1 / scale) * zoomCtr!.re + drafts.center.re() / scale);\n                    drafts.center.im((1 - 1 / scale) * zoomCtr!.im + drafts.center.im() / scale);\n                });\n            }\n        },\n        commit = () => S.freeze(() => {\n            zoomCtr = undefined;\n            drafts.zoom.commit();\n            drafts.center.re.commit();\n            drafts.center.im.commit();\n        });\n\n    canvas.addEventListener('wheel', onMouseWheel);\n    S.cleanup(() => canvas.removeEventListener('wheel', onMouseWheel));\n};\n","import * as Surplus from 'surplus';\nimport { App } from './app';\nimport { SettingsView } from './settingsView';\nimport { CanvasView } from './canvasView';\n\nexport const AppView = ({ app, mounted } : { app : App, mounted : () => boolean }) =>\n    <div class=\"app\">\n        <SettingsView app={app} />\n        <CanvasView app={app} mounted={mounted} />\n    </div>;\n","import S from 's-js';\nimport * as Surplus from 'surplus';\n\nimport { HashSignal } from './lib/hashSignal';\nimport { parseQueryString, formatQueryString } from './queryHandler';\nimport { App } from './app';\nimport { AppView } from './appView';\n\nconst\n    mounted = S.data(false),\n    view = S.root(() => {\n        const\n            hash = HashSignal(),\n            query = S(() => {\n                // NOTE: Referencing hash.change instead of hash to prevent\n                // cycle with two-way binding below. Same trick used in surplus-realword by Adam Haile:\n                // https://github.com/adamhaile/surplus-realworld/blob/master/src/main.tsx\n                const idx = hash.change().indexOf('?');\n                return idx >= 0 ? hash.change().slice(idx + 1) : '';\n            }),\n            opts = parseQueryString(S.sample(query)),\n            app = App((window as any).WORKER_URL, opts);\n\n        // Two-way binding btwn URL hash and App options\n        S(() => hash('#?' + formatQueryString(app.currentOpts())));\n        S.on(query, () => app.updateOpts(parseQueryString(query())));\n\n        return <AppView app={app} mounted={mounted} />;\n    });\ndocument.querySelector('#app')!.appendChild(view);\nmounted(true);\n"],"sourceRoot":""}