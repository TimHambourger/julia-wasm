{"version":3,"sources":["webpack:///./src/shared/memoryPool.ts","webpack:///./src/worker/workerCore.ts","webpack:///./wasm_output/julia_wasm.js"],"names":["MemoryPool","[object Object]","byteLength","this","stack","buffer","Error","push","buffers","i","length","pop","ArrayBuffer","WorkerCore","init","chunkSizePx","width","height","worker","bufferSize","_wasm_output_julia_wasm__WEBPACK_IMPORTED_MODULE_1__","new","workerConfig","pool","_shared_memoryPool__WEBPACK_IMPORTED_MODULE_0__","output","view","Uint16Array","_wasm_output_julia_wasm_bg__WEBPACK_IMPORTED_MODULE_2__","as_ptr","runner","dataGen","resumeTimeout","pendingMessages","msg","setAlarm","clearTimeout","setTimeout","processMessages","runJobs","sort","msg1","msg2","seqNo","resetMsgIdx","findIndex","type","resetMsg","addJobsMsgs","slice","reset","reverse","forEach","addJobs","free","escapeTime","c","re","im","maxIter","escapeRadius","canvas","chunkDelta","origin","jobs","job","push_job","topLeft","widthChunks","heightChunks","pushAll","startTime","performance","now","paused","pauseInterval","advance","load","chunkId","current_re","current_im","data","acquire","postMessage","_julia_wasm_bg__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","Buffer","ptr","arg0","__construct","EscapeTime","arg1","arg2","arg3","EscapeTimeRunner","ptr0","ptr1","Canvas","arg4","arg5","CanvasRect","slab","slab_next","addHeapObject","obj","idx","next","cnt","getObject","__wbindgen_object_clone_ref","__wbindgen_object_drop_ref","dropRef","cachedDecoder","TextDecoder","cachegetUint8Memory","getUint8Memory","Uint8Array","getStringFromWasm","len","decode","subarray","__wbindgen_string_new","p","l","__wbindgen_number_new","__wbindgen_number_get","n","invalid","__wbindgen_undefined_new","undefined","__wbindgen_null_new","__wbindgen_is_null","__wbindgen_is_undefined","__wbindgen_boolean_new","v","__wbindgen_boolean_get","__wbindgen_symbol_new","a","Symbol","__wbindgen_is_symbol","cachedEncoder","TextEncoder","cachegetUint32Memory","__wbindgen_string_get","len_ptr","arg","buf","encode","set","passStringToWasm","Uint32Array","__wbindgen_throw"],"mappings":"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","file":"workerCore.f1a9175dea2e982aecbf.js","sourcesContent":["export class MemoryPool {\n    private stack : ArrayBuffer[];\n\n    // TODO: Allow specifying a limit on the number of buffers to keep.\n    // To allow memory usage to drop if needs reduce.\n\n    constructor(\n        // Size in bytes\n        public readonly byteLength : number\n    ) {\n        this.stack = [];\n    }\n\n    /**\n     * Push a buffer back into the pool for later reuse.\n     * Throws if buffer is not at least `this.byteLength` bytes.\n     */\n    push(buffer : ArrayBuffer) {\n        if (buffer.byteLength < this.byteLength) {\n            throw new Error(`Can't absorb buffer. byteLength must be at least ${this.byteLength}`);\n        }\n        this.stack.push(buffer);\n    }\n\n    /**\n     * Push multiple buffers back into the pool.\n     * Throws if any buffer is less than `this.requiredSize()` bytes.\n     */\n    pushAll(buffers : ArrayBuffer[]) {\n        for (let i = 0; i < buffers.length; i++) {\n            this.push(buffers[i]);\n        }\n    }\n\n    /**\n     * Acquire a buffer from the pool, if one's available, otherwise constructs a new one\n     * with the min byte length.\n     */\n    acquire() {\n        return this.stack.pop() || new ArrayBuffer(this.byteLength);\n    }\n\n    /**\n     * Empty the pool and return the former contents.\n     */\n    drain() {\n        const stack = this.stack;\n        this.stack = [];\n        return stack;\n    }\n}\n","import { IWorkerConfig } from '../shared/config';\nimport { WorkerInstructionMsg, IWorkerInitMsg, IWorkerResetMsg, IAddJobsMsg, IChunkUpdateMsg } from '../shared/messages';\nimport { MemoryPool } from '../shared/memoryPool';\nimport { Buffer, Canvas, CanvasRect, EscapeTime, EscapeTimeRunner } from '../../wasm_output/julia_wasm';\nimport * as rawWasm from '../../wasm_output/julia_wasm_bg';\n\n// Basically, a Rust Vec<u16> represented as both an opaque Buffer object for passing\n// into Rust methods and as a Uint16Array for reading in JS.\ninterface OutputBuffer {\n    buffer : Buffer;\n    view : Uint16Array;\n}\n\n// With current webpack constraints, it's important that index.ts only import\n// WorkerCore as a type, not as a value. To get a handle on the WorkerCore class\n// constructor, index.ts must use an async import(...).\nexport type WorkerCoreType = InstanceType<typeof WorkerCore>;\nexport class WorkerCore {\n    private readonly workerConfig : IWorkerConfig;\n    private readonly pool : MemoryPool;\n    private readonly output : OutputBuffer;\n    private runner : EscapeTimeRunner | null;\n    private dataGen : number | null;\n    private resumeTimeout : number | null;\n    private pendingMessages : WorkerInstructionMsg[];\n\n    constructor(\n        init : IWorkerInitMsg\n    ) {\n        const\n            { chunkSizePx: { width, height } } = init.worker,\n            bufferSize = width * height,\n            buffer = Buffer.new(bufferSize);\n\n        this.workerConfig = init.worker;\n        // Times 2 to convert from u16 to u8\n        this.pool = new MemoryPool(bufferSize * 2);\n        this.output = {\n            buffer,\n            view: new Uint16Array(rawWasm.memory.buffer, buffer.as_ptr(), bufferSize),\n        };\n        this.runner = null;\n        this.dataGen = null;\n        this.resumeTimeout = null;\n        this.pendingMessages = [];\n    }\n\n    onmessage(msg : WorkerInstructionMsg) {\n        this.pendingMessages.push(msg);\n        this.setAlarm();\n    }\n\n    private setAlarm() {\n        if (this.resumeTimeout !== null) clearTimeout(this.resumeTimeout);\n        this.resumeTimeout = setTimeout(() => {\n            this.processMessages();\n            this.runJobs();\n        });\n    }\n\n    private processMessages() {\n        // Sort by sequence number descending\n        this.pendingMessages.sort((msg1, msg2) => msg2.seqNo - msg1.seqNo);\n        const\n            // Find the index of the last worker reset msg by seqNo. I.e. the first in our descending sort.\n            resetMsgIdx = this.pendingMessages.findIndex(msg => msg.type === 'worker-reset'),\n            resetMsg = resetMsgIdx >= 0 ? this.pendingMessages[resetMsgIdx] : null,\n            // Add jobs messages sent before the most recent reset message get thrown away.\n            addJobsMsgs = resetMsgIdx >= 0 ? this.pendingMessages.slice(0, resetMsgIdx) : this.pendingMessages;\n\n        if (resetMsg) {\n            // We validated this above. Re-asserting here gets back strong typing w/o needing a brittle cast.\n            if (resetMsg.type !== 'worker-reset') throw new Error(`Unexpected reset msg type: ${resetMsg.type}`);\n            this.reset(resetMsg);\n        }\n\n        // Now sort by seq no ascending. We want to push jobs in the order they were sent.\n        addJobsMsgs.reverse();\n        addJobsMsgs.forEach(msg => {\n            // We validated this above. Re-asserting here gets back strong typing w/o needing a brittle cast.\n            if (msg.type === 'worker-reset') throw new Error(`Unexpected msg type: ${msg.type}`);\n            this.addJobs(msg);\n        });\n        this.pendingMessages = [];\n    }\n\n    private reset(msg : IWorkerResetMsg) {\n        if (this.runner) this.runner.free();\n        this.runner = EscapeTimeRunner.new(\n            EscapeTime.new(\n                msg.escapeTime.c.re,\n                msg.escapeTime.c.im,\n                msg.escapeTime.maxIter,\n                msg.escapeTime.escapeRadius\n            ),\n            Canvas.new(\n                this.workerConfig.chunkSizePx.width,\n                this.workerConfig.chunkSizePx.height,\n                msg.canvas.chunkDelta.re,\n                msg.canvas.chunkDelta.im,\n                msg.canvas.origin.re,\n                msg.canvas.origin.im\n            )\n        );\n        this.dataGen = msg.dataGen;\n    }\n\n    private addJobs(msg : IAddJobsMsg) {\n        if (this.runner) {\n            msg.jobs.forEach(job => {\n                this.runner!.push_job(CanvasRect.new(job.topLeft.re, job.topLeft.im, job.widthChunks, job.heightChunks));\n            });\n        }\n        if (msg.buffers) this.pool.pushAll(msg.buffers);\n    }\n\n    private runJobs() {\n        if (!this.runner || this.dataGen === null) return;\n\n        const startTime = performance.now();\n        // Track whether we exit while loop b/c we run out of chunks or out of time.\n        let paused = false;\n        // Continue processing until we hit pause interval or run out of chunks.\n        // Check pause interval BEFORE advancing runner so we don't advance runner w/o\n        // then loading chunk data.\n        while (!(paused = performance.now() - startTime >= this.workerConfig.pauseInterval) && this.runner.advance()) {\n            this.runner.load(this.output.buffer);\n            const\n                chunkId = {\n                    re: this.runner.current_re(),\n                    im: this.runner.current_im()\n                },\n                data = this.pool.acquire(),\n                view = new Uint16Array(data);\n\n            for (let i = 0; i < view.length && i < this.output.view.length; i++) {\n                view[i] = this.output.view[i];\n            }\n\n            const msg : IChunkUpdateMsg = {\n                type: 'chunk-update',\n                chunkId,\n                dataGen: this.dataGen,\n                data\n            };\n            postMessage(msg, [data]);\n        }\n\n        // If we exited loop b/c we hit our pause interval, setAlarm to keep processing\n        // after giving onmessage events a chance to fire.\n        if (paused) this.setAlarm();\n    }\n}\n","/* tslint:disable */\nimport * as wasm from './julia_wasm_bg';\n\nexport class Buffer {\n\n                static __construct(ptr) {\n                    return new Buffer(ptr);\n                }\n\n                constructor(ptr) {\n                    this.ptr = ptr;\n                }\n\n            free() {\n                const ptr = this.ptr;\n                this.ptr = 0;\n                wasm.__wbg_buffer_free(ptr);\n            }\n        static new(arg0) {\n    return Buffer.__construct(wasm.buffer_new(arg0));\n}\nas_ptr() {\n    return wasm.buffer_as_ptr(this.ptr);\n}\n}\n\nexport class EscapeTime {\n\n                static __construct(ptr) {\n                    return new EscapeTime(ptr);\n                }\n\n                constructor(ptr) {\n                    this.ptr = ptr;\n                }\n\n            free() {\n                const ptr = this.ptr;\n                this.ptr = 0;\n                wasm.__wbg_escapetime_free(ptr);\n            }\n        static new(arg0, arg1, arg2, arg3) {\n    return EscapeTime.__construct(wasm.escapetime_new(arg0, arg1, arg2, arg3));\n}\n}\n\nexport class EscapeTimeRunner {\n\n                static __construct(ptr) {\n                    return new EscapeTimeRunner(ptr);\n                }\n\n                constructor(ptr) {\n                    this.ptr = ptr;\n                }\n\n            free() {\n                const ptr = this.ptr;\n                this.ptr = 0;\n                wasm.__wbg_escapetimerunner_free(ptr);\n            }\n        static new(arg0, arg1) {\n    const ptr0 = arg0.ptr;\n    arg0.ptr = 0;\n    const ptr1 = arg1.ptr;\n    arg1.ptr = 0;\n    return EscapeTimeRunner.__construct(wasm.escapetimerunner_new(ptr0, ptr1));\n}\npush_job(arg0) {\n    const ptr0 = arg0.ptr;\n    arg0.ptr = 0;\n    return wasm.escapetimerunner_push_job(this.ptr, ptr0);\n}\nadvance() {\n    return (wasm.escapetimerunner_advance(this.ptr)) !== 0;\n}\ncurrent_re() {\n    return wasm.escapetimerunner_current_re(this.ptr);\n}\ncurrent_im() {\n    return wasm.escapetimerunner_current_im(this.ptr);\n}\nload(arg0) {\n    return wasm.escapetimerunner_load(this.ptr, arg0.ptr);\n}\n}\n\nexport class Canvas {\n\n                static __construct(ptr) {\n                    return new Canvas(ptr);\n                }\n\n                constructor(ptr) {\n                    this.ptr = ptr;\n                }\n\n            free() {\n                const ptr = this.ptr;\n                this.ptr = 0;\n                wasm.__wbg_canvas_free(ptr);\n            }\n        static new(arg0, arg1, arg2, arg3, arg4, arg5) {\n    return Canvas.__construct(wasm.canvas_new(arg0, arg1, arg2, arg3, arg4, arg5));\n}\n}\n\nexport class CanvasRect {\n\n                static __construct(ptr) {\n                    return new CanvasRect(ptr);\n                }\n\n                constructor(ptr) {\n                    this.ptr = ptr;\n                }\n\n            free() {\n                const ptr = this.ptr;\n                this.ptr = 0;\n                wasm.__wbg_canvasrect_free(ptr);\n            }\n        static new(arg0, arg1, arg2, arg3) {\n    return CanvasRect.__construct(wasm.canvasrect_new(arg0, arg1, arg2, arg3));\n}\n}\n\nlet slab = [];\n\nlet slab_next = 0;\n\nfunction addHeapObject(obj) {\n    if (slab_next === slab.length)\n        slab.push(slab.length + 1);\n    const idx = slab_next;\n    const next = slab[idx];\n\n    slab_next = next;\n\n    slab[idx] = { obj, cnt: 1 };\n    return idx << 1;\n}\n\nlet stack = [];\n\nfunction getObject(idx) {\n    if ((idx & 1) === 1) {\n        return stack[idx >> 1];\n    } else {\n        const val = slab[idx >> 1];\n\n    return val.obj;\n\n    }\n}\n\nexport function __wbindgen_object_clone_ref(idx) {\n    // If this object is on the stack promote it to the heap.\n    if ((idx & 1) === 1)\n        return addHeapObject(getObject(idx));\n\n    // Otherwise if the object is on the heap just bump the\n    // refcount and move on\n    const val = slab[idx >> 1];\n    val.cnt += 1;\n    return idx;\n}\n\nfunction dropRef(idx) {\n\n    let obj = slab[idx >> 1];\n\n    obj.cnt -= 1;\n    if (obj.cnt > 0)\n        return;\n\n    // If we hit 0 then free up our space in the slab\n    slab[idx >> 1] = slab_next;\n    slab_next = idx >> 1;\n}\n\nexport function __wbindgen_object_drop_ref(i) { dropRef(i); }\n\nlet cachedDecoder = new TextDecoder('utf-8');\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null ||\n        cachegetUint8Memory.buffer !== wasm.memory.buffer)\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    return cachegetUint8Memory;\n}\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nexport function __wbindgen_string_new(p, l) {\n    return addHeapObject(getStringFromWasm(p, l));\n}\n\nexport function __wbindgen_number_new(i) { return addHeapObject(i); }\n\nexport function __wbindgen_number_get(n, invalid) {\n    let obj = getObject(n);\n    if (typeof(obj) === 'number')\n        return obj;\n    getUint8Memory()[invalid] = 1;\n    return 0;\n}\n\nexport function __wbindgen_undefined_new() { return addHeapObject(undefined); }\n\nexport function __wbindgen_null_new() {\n    return addHeapObject(null);\n}\n\nexport function __wbindgen_is_null(idx) {\n    return getObject(idx) === null ? 1 : 0;\n}\n\nexport function __wbindgen_is_undefined(idx) {\n    return getObject(idx) === undefined ? 1 : 0;\n}\n\nexport function __wbindgen_boolean_new(v) {\n    return addHeapObject(v === 1);\n}\n\nexport function __wbindgen_boolean_get(i) {\n    let v = getObject(i);\n    if (typeof(v) === 'boolean') {\n        return v ? 1 : 0;\n    } else {\n        return 2;\n    }\n}\n\nexport function __wbindgen_symbol_new(ptr, len) {\n    let a;\n    if (ptr === 0) {\n        a = Symbol();\n    } else {\n        a = Symbol(getStringFromWasm(ptr, len));\n    }\n    return addHeapObject(a);\n}\n\nexport function __wbindgen_is_symbol(i) {\n    return typeof(getObject(i)) === 'symbol' ? 1 : 0;\n}\n\nlet cachedEncoder = new TextEncoder('utf-8');\n\nfunction passStringToWasm(arg) {\n\n    const buf = cachedEncoder.encode(arg);\n    const ptr = wasm.__wbindgen_malloc(buf.length);\n    getUint8Memory().set(buf, ptr);\n    return [ptr, buf.length];\n}\n\nlet cachegetUint32Memory = null;\nfunction getUint32Memory() {\n    if (cachegetUint32Memory === null ||\n        cachegetUint32Memory.buffer !== wasm.memory.buffer)\n        cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n    return cachegetUint32Memory;\n}\n\nexport function __wbindgen_string_get(i, len_ptr) {\n    let obj = getObject(i);\n    if (typeof(obj) !== 'string')\n        return 0;\n    const [ptr, len] = passStringToWasm(obj);\n    getUint32Memory()[len_ptr / 4] = len;\n    return ptr;\n}\n\nexport function __wbindgen_throw(ptr, len) {\n    throw new Error(getStringFromWasm(ptr, len));\n}\n\n"],"sourceRoot":""}