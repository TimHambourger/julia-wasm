{"version":3,"sources":["webpack:///./src/shared/memoryPool.ts","webpack:///./src/worker/workerCore.ts","webpack:///./wasm_output/julia_wasm.js"],"names":["MemoryPool","[object Object]","byteLength","this","stack","buffer","Error","push","buffers","i","length","pop","ArrayBuffer","WorkerCore","init","chunkSizePx","width","height","worker","bufferSize","_wasm_output_julia_wasm__WEBPACK_IMPORTED_MODULE_1__","new","workerConfig","pool","_shared_memoryPool__WEBPACK_IMPORTED_MODULE_0__","output","view","Uint16Array","_wasm_output_julia_wasm_bg__WEBPACK_IMPORTED_MODULE_2__","as_ptr","runner","dataGen","resumeTimeout","pendingMessages","msg","setAlarm","clearTimeout","setTimeout","processMessages","runJobs","sort","msg1","msg2","seqNo","resetMsgIdx","findIndex","type","resetMsg","addJobsMsgs","slice","reset","reverse","forEach","addJobs","free","escapeTime","c","re","im","maxIter","escapeRadius","canvas","chunkDelta","origin","jobs","job","push_job","topLeft","widthChunks","heightChunks","pushAll","startTime","performance","now","paused","pauseInterval","advance","load","chunkId","current_re","current_im","data","acquire","postMessage","_julia_wasm_bg__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","Buffer","ptr","arg0","__construct","CanvasRect","arg1","arg2","arg3","EscapeTimeRunner","ptr0","ptr1","Canvas","arg4","arg5","EscapeTime","cachedDecoder","TextDecoder","cachegetUint8Memory","getStringFromWasm","len","decode","Uint8Array","subarray","__wbindgen_throw"],"mappings":"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","file":"workerCore.724301a23463f898b691.js","sourcesContent":["export class MemoryPool {\n    private stack : ArrayBuffer[];\n\n    // TODO: Allow specifying a limit on the number of buffers to keep.\n    // To allow memory usage to drop if needs reduce.\n\n    constructor(\n        // Size in bytes\n        public readonly byteLength : number\n    ) {\n        this.stack = [];\n    }\n\n    /**\n     * Push a buffer back into the pool for later reuse.\n     * Throws if buffer is not at least `this.byteLength` bytes.\n     */\n    push(buffer : ArrayBuffer) {\n        if (buffer.byteLength < this.byteLength) {\n            throw new Error(`Can't absorb buffer. byteLength must be at least ${this.byteLength}`);\n        }\n        this.stack.push(buffer);\n    }\n\n    /**\n     * Push multiple buffers back into the pool.\n     * Throws if any buffer is less than `this.requiredSize()` bytes.\n     */\n    pushAll(buffers : ArrayBuffer[]) {\n        for (let i = 0; i < buffers.length; i++) {\n            this.push(buffers[i]);\n        }\n    }\n\n    /**\n     * Acquire a buffer from the pool, if one's available, otherwise constructs a new one\n     * with the min byte length.\n     */\n    acquire() {\n        return this.stack.pop() || new ArrayBuffer(this.byteLength);\n    }\n\n    /**\n     * Empty the pool and return the former contents.\n     */\n    drain() {\n        const stack = this.stack;\n        this.stack = [];\n        return stack;\n    }\n}\n","import { IWorkerConfig } from '../shared/config';\nimport { WorkerInstructionMsg, IWorkerInitMsg, IWorkerResetMsg, IAddJobsMsg, IChunkUpdateMsg } from '../shared/messages';\nimport { MemoryPool } from '../shared/memoryPool';\nimport { Buffer, Canvas, CanvasRect, EscapeTime, EscapeTimeRunner } from '../../wasm_output/julia_wasm';\nimport * as rawWasm from '../../wasm_output/julia_wasm_bg';\n\n// Basically, a Rust Vec<u16> represented as both an opaque Buffer object for passing\n// into Rust methods and as a Uint16Array for reading in JS.\ninterface OutputBuffer {\n    buffer : Buffer;\n    view : Uint16Array;\n}\n\n// With current webpack constraints, it's important that index.ts only import\n// WorkerCore as a type, not as a value. To get a handle on the WorkerCore class\n// constructor, index.ts must use an async import(...).\n// To help enforce this constraint, expose a WorkerCoreType that makes misuse\n// easier to spot.\nexport type WorkerCoreType = WorkerCore;\nexport class WorkerCore {\n    private readonly workerConfig : IWorkerConfig;\n    private readonly pool : MemoryPool;\n    private readonly output : OutputBuffer;\n    private runner : EscapeTimeRunner | null;\n    private dataGen : number | null;\n    private resumeTimeout : number | null;\n    private pendingMessages : WorkerInstructionMsg[];\n\n    constructor(\n        init : IWorkerInitMsg\n    ) {\n        const\n            { chunkSizePx: { width, height } } = init.worker,\n            bufferSize = width * height,\n            buffer = Buffer.new(bufferSize);\n\n        this.workerConfig = init.worker;\n        // Times 2 to convert from u16 to u8\n        this.pool = new MemoryPool(bufferSize * 2);\n        this.output = {\n            buffer,\n            view: new Uint16Array(rawWasm.memory.buffer, buffer.as_ptr(), bufferSize),\n        };\n        this.runner = null;\n        this.dataGen = null;\n        this.resumeTimeout = null;\n        this.pendingMessages = [];\n    }\n\n    onmessage(msg : WorkerInstructionMsg) {\n        this.pendingMessages.push(msg);\n        this.setAlarm();\n    }\n\n    private setAlarm() {\n        if (this.resumeTimeout !== null) clearTimeout(this.resumeTimeout);\n        this.resumeTimeout = setTimeout(() => {\n            this.processMessages();\n            this.runJobs();\n        });\n    }\n\n    private processMessages() {\n        // Sort by sequence number descending\n        this.pendingMessages.sort((msg1, msg2) => msg2.seqNo - msg1.seqNo);\n        const\n            // Find the index of the last worker reset msg by seqNo. I.e. the first in our descending sort.\n            resetMsgIdx = this.pendingMessages.findIndex(msg => msg.type === 'worker-reset'),\n            resetMsg = resetMsgIdx >= 0 ? this.pendingMessages[resetMsgIdx] : null,\n            // Add jobs messages sent before the most recent reset message get thrown away.\n            addJobsMsgs = resetMsgIdx >= 0 ? this.pendingMessages.slice(0, resetMsgIdx) : this.pendingMessages;\n\n        if (resetMsg) {\n            // We validated this above. Re-asserting here gets back strong typing w/o needing a brittle cast.\n            if (resetMsg.type !== 'worker-reset') throw new Error(`Unexpected reset msg type: ${resetMsg.type}`);\n            this.reset(resetMsg);\n        }\n\n        // Now sort by seq no ascending. We want to push jobs in the order they were sent.\n        addJobsMsgs.reverse();\n        addJobsMsgs.forEach(msg => {\n            // We validated this above. Re-asserting here gets back strong typing w/o needing a brittle cast.\n            if (msg.type === 'worker-reset') throw new Error(`Unexpected msg type: ${msg.type}`);\n            this.addJobs(msg);\n        });\n        this.pendingMessages = [];\n    }\n\n    private reset(msg : IWorkerResetMsg) {\n        if (this.runner) this.runner.free();\n        this.runner = EscapeTimeRunner.new(\n            EscapeTime.new(\n                msg.escapeTime.c.re,\n                msg.escapeTime.c.im,\n                msg.escapeTime.maxIter,\n                msg.escapeTime.escapeRadius\n            ),\n            Canvas.new(\n                this.workerConfig.chunkSizePx.width,\n                this.workerConfig.chunkSizePx.height,\n                msg.canvas.chunkDelta.re,\n                msg.canvas.chunkDelta.im,\n                msg.canvas.origin.re,\n                msg.canvas.origin.im\n            )\n        );\n        this.dataGen = msg.dataGen;\n    }\n\n    private addJobs(msg : IAddJobsMsg) {\n        if (this.runner) {\n            msg.jobs.forEach(job => {\n                this.runner!.push_job(CanvasRect.new(job.topLeft.re, job.topLeft.im, job.widthChunks, job.heightChunks));\n            });\n        }\n        if (msg.buffers) this.pool.pushAll(msg.buffers);\n    }\n\n    private runJobs() {\n        if (!this.runner || this.dataGen === null) return;\n\n        const startTime = performance.now();\n        // Track whether we exit while loop b/c we run out of chunks or out of time.\n        let paused = false;\n        // Continue processing until we hit pause interval or run out of chunks.\n        // Check pause interval BEFORE advancing runner so we don't advance runner w/o\n        // then loading chunk data.\n        while (!(paused = performance.now() - startTime >= this.workerConfig.pauseInterval) && this.runner.advance()) {\n            this.runner.load(this.output.buffer);\n            const\n                chunkId = {\n                    re: this.runner.current_re(),\n                    im: this.runner.current_im()\n                },\n                data = this.pool.acquire(),\n                view = new Uint16Array(data);\n\n            for (let i = 0; i < view.length && i < this.output.view.length; i++) {\n                view[i] = this.output.view[i];\n            }\n\n            const msg : IChunkUpdateMsg = {\n                type: 'chunk-update',\n                chunkId,\n                dataGen: this.dataGen,\n                data\n            };\n            postMessage(msg, [data]);\n        }\n\n        // If we exited loop b/c we hit our pause interval, setAlarm to keep processing\n        // after giving onmessage events a chance to fire.\n        if (paused) this.setAlarm();\n    }\n}\n","/* tslint:disable */\nimport * as wasm from './julia_wasm_bg';\n\n/**\n*/\nexport class Buffer {\n    \n    static __construct(ptr) {\n        return new Buffer(ptr);\n    }\n    \n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    \n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_buffer_free(ptr);\n    }\n    /**\n    * @param {number} arg0\n    * @returns {Buffer}\n    */\n    static new(arg0) {\n        return Buffer.__construct(wasm.buffer_new(arg0));\n    }\n    /**\n    * @returns {number}\n    */\n    as_ptr() {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        return wasm.buffer_as_ptr(this.ptr);\n    }\n}\n/**\n*/\nexport class CanvasRect {\n    \n    static __construct(ptr) {\n        return new CanvasRect(ptr);\n    }\n    \n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    \n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_canvasrect_free(ptr);\n    }\n    /**\n    * @param {number} arg0\n    * @param {number} arg1\n    * @param {number} arg2\n    * @param {number} arg3\n    * @returns {CanvasRect}\n    */\n    static new(arg0, arg1, arg2, arg3) {\n        return CanvasRect.__construct(wasm.canvasrect_new(arg0, arg1, arg2, arg3));\n    }\n}\n/**\n*/\nexport class EscapeTimeRunner {\n    \n    static __construct(ptr) {\n        return new EscapeTimeRunner(ptr);\n    }\n    \n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    \n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_escapetimerunner_free(ptr);\n    }\n    /**\n    * @param {EscapeTime} arg0\n    * @param {Canvas} arg1\n    * @returns {EscapeTimeRunner}\n    */\n    static new(arg0, arg1) {\n        const ptr0 = arg0.ptr;\n        if (ptr0 === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        arg0.ptr = 0;\n        const ptr1 = arg1.ptr;\n        if (ptr1 === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        arg1.ptr = 0;\n        return EscapeTimeRunner.__construct(wasm.escapetimerunner_new(ptr0, ptr1));\n    }\n    /**\n    * Add a job to the runner. This job will take priority over previously added jobs.\n    * @param {CanvasRect} arg0\n    * @returns {void}\n    */\n    push_job(arg0) {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        const ptr0 = arg0.ptr;\n        if (ptr0 === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        arg0.ptr = 0;\n        return wasm.escapetimerunner_push_job(this.ptr, ptr0);\n    }\n    /**\n    * If the runner has a next chunk, advance to it and return true.\n    * Otherwise return false.\n    * @returns {boolean}\n    */\n    advance() {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        return (wasm.escapetimerunner_advance(this.ptr)) !== 0;\n    }\n    /**\n    * Real component of the current chunk\\'s ChunkId.\n    * ChunkIds represent the position of the chunk\\'s top left corner relative\n    * to the canvas origin, measured in chunks.\n    * ChunkIds increase from left to right and from top to bottom.\n    *\n    * # Panics\n    *\n    * If there\\'s no current chunk.\n    * Use the return value of `advance` to determine if there\\'s a current chunk before calling this method.\n    * @returns {number}\n    */\n    current_re() {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        return wasm.escapetimerunner_current_re(this.ptr);\n    }\n    /**\n    * Imaginary component of the current chunk\\'s ChunkId.\n    * ChunkIds represent the position of the chunk\\'s top left corner relative\n    * to the canvas origin, measured in chunks.\n    * ChunkIds increase from left to right and from top to bottom.\n    *\n    * # Panics\n    *\n    * If there\\'s no current chunk.\n    * Use the return value of `advance` to determine if there\\'s a current chunk before calling this method.\n    * @returns {number}\n    */\n    current_im() {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        return wasm.escapetimerunner_current_im(this.ptr);\n    }\n    /**\n    * Load escape time data for the current chunk into the provided output buffer.\n    *\n    * # Panics\n    *\n    * If there\\'s no current chunk to load or if the provided output buffer is insufficient.\n    * Use the return value of `advance` to determine if there\\'s a current chunk before calling this method.\n    * @param {Buffer} arg0\n    * @returns {void}\n    */\n    load(arg0) {\n        if (this.ptr === 0) {\n            throw new Error('Attempt to use a moved value');\n        }\n        return wasm.escapetimerunner_load(this.ptr, arg0.ptr);\n    }\n}\n/**\n*/\nexport class Canvas {\n    \n    static __construct(ptr) {\n        return new Canvas(ptr);\n    }\n    \n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    \n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_canvas_free(ptr);\n    }\n    /**\n    * @param {number} arg0\n    * @param {number} arg1\n    * @param {number} arg2\n    * @param {number} arg3\n    * @param {number} arg4\n    * @param {number} arg5\n    * @returns {Canvas}\n    */\n    static new(arg0, arg1, arg2, arg3, arg4, arg5) {\n        return Canvas.__construct(wasm.canvas_new(arg0, arg1, arg2, arg3, arg4, arg5));\n    }\n}\n/**\n*/\nexport class EscapeTime {\n    \n    static __construct(ptr) {\n        return new EscapeTime(ptr);\n    }\n    \n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    \n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_escapetime_free(ptr);\n    }\n    /**\n    * @param {number} arg0\n    * @param {number} arg1\n    * @param {number} arg2\n    * @param {number} arg3\n    * @returns {EscapeTime}\n    */\n    static new(arg0, arg1, arg2, arg3) {\n        return EscapeTime.__construct(wasm.escapetime_new(arg0, arg1, arg2, arg3));\n    }\n}\n\nlet cachedDecoder = new TextDecoder('utf-8');\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nexport function __wbindgen_throw(ptr, len) {\n    throw new Error(getStringFromWasm(ptr, len));\n}\n\n"],"sourceRoot":""}